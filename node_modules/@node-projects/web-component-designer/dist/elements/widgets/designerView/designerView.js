import { PointerActionType } from "../../../enums/PointerActionType.js";
import { EventNames } from "../../../enums/EventNames.js";
import { InstanceServiceContainer } from "../../services/InstanceServiceContainer.js";
import { UndoService } from "../../services/undoService/UndoService.js";
import { SelectionService } from "../../services/selectionService/SelectionService.js";
import { DesignItem } from "../../item/DesignItem.js";
import { BaseCustomWebComponentLazyAppend, css, html } from "../../../../../base-custom-webcomponent/dist/index.js";
import { dragDropFormatName } from "../../../Constants.js";
import { ContentService } from "../../services/contentService/ContentService.js";
import { InsertAction } from "../../services/undoService/transactionItems/InsertAction.js";
import { DomConverter } from "./DomConverter.js";
import { Snaplines } from "./Snaplines.js";
import { ContextMenuHelper } from "../../helper/contextMenu/ContextMenuHelper.js";
import { DeleteAction } from "../../services/undoService/transactionItems/DeleteAction.js";
import { CommandType } from "../../../commandHandling/CommandType.js";
import { MoveElementInDomAction } from "../../services/undoService/transactionItems/MoveElementInDomAction.js";
import { DefaultHtmlParserService } from "../../services/htmlParserService/DefaultHtmlParserService.js";
import { ExtensionType } from "./extensions/ExtensionType.js";
import { ExtensionManager } from "./extensions/ExtensionManager.js";
export class DesignerView extends BaseCustomWebComponentLazyAppend {
  constructor() {
    super(); // IPlacementView

    this.gridSize = 10;
    this.alignOnGrid = false;
    this.alignOnSnap = true;
    this._zoomFactor = 1;
    this._movedSinceStartedAction = false;
    this._clickThroughElements = [];
    this._canvas = this._getDomElement('canvas');
    this._canvasContainer = this._getDomElement('canvasContainer');
    this._outercanvas2 = this._getDomElement('outercanvas2');
    this._selector = this._getDomElement('selector');
    this._zoomInput = this._getDomElement('zoomInput');

    this._zoomInput.onchange = () => {
      this._zoomFactor = parseInt(this._zoomInput.value) / 100;
      this.zoomFactorChanged();
    };

    this._zoomInput.onclick = this._zoomInput.select;

    let zoomIncrease = this._getDomElement('zoomIncrease');

    zoomIncrease.onclick = () => {
      this._zoomFactor += 0.1;
      this.zoomFactorChanged();
    };

    let zoomDecrease = this._getDomElement('zoomDecrease');

    zoomDecrease.onclick = () => {
      this._zoomFactor -= 0.1;
      this.zoomFactorChanged();
    };

    let zoomReset = this._getDomElement('zoomReset');

    zoomReset.onclick = () => {
      this._zoomFactor = 1;
      this.zoomFactorChanged();
    };

    let zoomFit = this._getDomElement('zoomFit');

    zoomFit.onclick = () => {
      this._zoomFactor = 7.7;
      this.zoomFactorChanged();
    };

    let alignSnap = this._getDomElement('alignSnap');

    alignSnap.onclick = () => {
      this.alignOnSnap = !this.alignOnSnap;
      alignSnap.style.backgroundColor = this.alignOnSnap ? 'deepskyblue' : '';
    };

    alignSnap.style.backgroundColor = this.alignOnSnap ? 'deepskyblue' : '';

    let alignGrid = this._getDomElement('alignGrid');

    alignGrid.onclick = () => {
      this.alignOnGrid = !this.alignOnGrid;
      alignGrid.style.backgroundColor = this.alignOnGrid ? 'deepskyblue' : '';
    };

    alignGrid.style.backgroundColor = this.alignOnGrid ? 'deepskyblue' : '';
    this.instanceServiceContainer = new InstanceServiceContainer();
    this.instanceServiceContainer.register("undoService", new UndoService());
    this.instanceServiceContainer.register("selectionService", new SelectionService());
    this._extensionManger = new ExtensionManager(this);
    this._onKeyDownBound = this.onKeyDown.bind(this);
    this._onKeyUpBound = this.onKeyUp.bind(this);
    this._onContextMenuBound = this._onContextMenu.bind(this);
    this._pointerEventHandlerBound = this._pointerEventHandler.bind(this);
    this._canvas.oncontextmenu = this._onContextMenuBound;
    this.instanceServiceContainer.selectionService.onSelectionChanged.on(this._selectedElementsChanged.bind(this));
    this.overlayLayer = this._getDomElement('svg');
    this.snapLines = new Snaplines(this.overlayLayer);
  }

  get designerWidth() {
    return this._canvasContainer.style.width;
  }

  set designerWidth(value) {
    this._canvasContainer.style.width = value;
    this.zoomFactorChanged();
  }

  get designerHeight() {
    return this._canvasContainer.style.height;
  }

  set designerHeight(value) {
    this._canvasContainer.style.height = value;
    this.zoomFactorChanged();
  }

  set additionalStyle(value) {
    if (value) {
      for (let r of value.rules) {
        if (r instanceof CSSStyleRule) {
          let parts = r.selectorText.split(',');
          r.selectorText = '';

          for (let p of parts) {
            if (r.selectorText) r.selectorText += ',';
            r.selectorText += '#canvas ' + p;
          }
        }
      } //@ts-ignore


      this.shadowRoot.adoptedStyleSheets = [this.constructor.style, value];
    } else //@ts-ignore
      this.shadowRoot.adoptedStyleSheets = [this.constructor.style];
  }
  /* --- start IUiCommandHandler --- */


  executeCommand(command) {
    switch (command.type) {
      case CommandType.delete:
        this.handleDeleteCommand();
        break;

      case CommandType.undo:
        this.instanceServiceContainer.undoService.undo();
        break;

      case CommandType.redo:
        this.instanceServiceContainer.undoService.redo();
        break;

      case CommandType.moveToFront:
      case CommandType.moveForward:
      case CommandType.moveBackward:
      case CommandType.moveToBack:
        this.handleMoveCommand(command.type);
        break;

      case CommandType.copy:
        this.handleCopyCommand();
        break;

      case CommandType.cut:
        this.handleCopyCommand();
        this.handleDeleteCommand();
        break;

      case CommandType.paste:
        this.handlePasteCommand();
        break;
    }
  }

  canExecuteCommand(command) {
    if (command.type === CommandType.undo) {
      return this.instanceServiceContainer.undoService.canUndo();
    }

    if (command.type === CommandType.redo) {
      return this.instanceServiceContainer.undoService.canRedo();
    }

    return true;
  }
  /* --- end IUiCommandHandler --- */


  handleCopyCommand() {
    const copyText = DomConverter.ConvertToString(this.instanceServiceContainer.selectionService.selectedElements, null);
    navigator.clipboard.writeText(copyText);
  }

  async handlePasteCommand() {
    const text = await navigator.clipboard.readText();
    const parserService = this.serviceContainer.htmlParserService;
    let grp = this.rootDesignItem.openGroup("Insert");
    const designItems = await parserService.parse(text, this.serviceContainer, this.instanceServiceContainer);

    if (designItems) {
      for (let di of designItems) {
        this.instanceServiceContainer.undoService.execute(new InsertAction(this.rootDesignItem, this._canvas.children.length, di));
      }

      const intializationService = this.serviceContainer.intializationService;

      if (intializationService) {
        for (let di of designItems) intializationService.init(di);
      }

      this.instanceServiceContainer.selectionService.setSelectedElements(designItems);
    }

    grp.commit();
    this.snapLines.clearSnaplines();
  }

  handleDeleteCommand() {
    let items = this.instanceServiceContainer.selectionService.selectedElements;
    this.instanceServiceContainer.undoService.execute(new DeleteAction(items));
    this.instanceServiceContainer.selectionService.setSelectedElements(null);
  }

  handleMoveCommand(command) {
    //todo -> via undo redo service
    let sel = this.instanceServiceContainer.selectionService.primarySelection;
    if (command == CommandType.moveBackward) this.instanceServiceContainer.undoService.execute(new MoveElementInDomAction(sel, DesignItem.GetDesignItem(sel.element.previousElementSibling), 'beforebegin', DesignItem.GetDesignItem(sel.element.previousElementSibling), 'afterend'));else if (command == CommandType.moveForward) this.instanceServiceContainer.undoService.execute(new MoveElementInDomAction(sel, DesignItem.GetDesignItem(sel.element.nextElementSibling), 'afterend', DesignItem.GetDesignItem(sel.element.nextElementSibling), 'beforebegin'));else if (command == CommandType.moveToBack) this.instanceServiceContainer.undoService.execute(new MoveElementInDomAction(sel, DesignItem.GetDesignItem(sel.element.parentElement), 'afterbegin', DesignItem.GetDesignItem(sel.element.previousElementSibling), 'afterend'));else if (command == CommandType.moveToFront) this.instanceServiceContainer.undoService.execute(new MoveElementInDomAction(sel, DesignItem.GetDesignItem(sel.element.parentElement), 'beforeend', DesignItem.GetDesignItem(sel.element.nextElementSibling), 'beforebegin'));
  }

  initialize(serviceContainer) {
    this.serviceContainer = serviceContainer;
    this.rootDesignItem = DesignItem.GetOrCreateDesignItem(this._canvas, this.serviceContainer, this.instanceServiceContainer);
    this.instanceServiceContainer.register("contentService", new ContentService(this.rootDesignItem));
    this.snapLines.initialize(this.rootDesignItem);

    if (this.children) {
      const parser = this.serviceContainer.getLastServiceWhere('htmlParserService', x => x.constructor == DefaultHtmlParserService);

      this._addDesignItems(parser.createDesignItems(this.children, this.serviceContainer, this.instanceServiceContainer));
    }
  }

  static wrapInDesigner(elements, serviceContainer) {
    let designerView = new DesignerView();
    designerView.initialize(serviceContainer);
    const parser = designerView.serviceContainer.getLastServiceWhere('htmlParserService', x => x.constructor == DefaultHtmlParserService);

    designerView._addDesignItems(parser.createDesignItems(elements, designerView.serviceContainer, designerView.instanceServiceContainer));

    return designerView;
  }

  connectedCallback() {
    if (!this._firstConnect) {
      this._firstConnect = true;

      this._outercanvas2.addEventListener(EventNames.PointerDown, this._pointerEventHandlerBound);

      this._outercanvas2.addEventListener(EventNames.PointerMove, this._pointerEventHandlerBound);

      this._canvas.addEventListener(EventNames.DragEnter, event => this._onDragEnter(event));

      this._canvas.addEventListener(EventNames.DragOver, event => this._onDragOver(event));

      this._canvas.addEventListener(EventNames.Drop, event => this._onDrop(event));

      this._canvas.addEventListener('keydown', this._onKeyDownBound, true);

      this._canvas.addEventListener('keyup', this._onKeyUpBound, true);

      this.addEventListener(EventNames.Wheel, event => this._onWheel(event));
    }

    window.addEventListener(EventNames.PointerUp, this._pointerEventHandlerBound);
  }

  disconnectedCallback() {
    window.removeEventListener(EventNames.PointerUp, this._pointerEventHandlerBound);
  }

  zoomFactorChanged() {
    this._canvasContainer.style.zoom = this._zoomFactor;
    this._zoomInput.value = (this._zoomFactor * 100).toFixed(0) + '%';
    this._canvasContainer.style.bottom = this._outercanvas2.offsetHeight >= this._canvasContainer.offsetHeight ? '0' : '';
    this._canvasContainer.style.right = this._outercanvas2.offsetWidth >= this._canvasContainer.offsetWidth ? '0' : '';
    this.snapLines.clearSnaplines();
  }

  getHTML(designItemsAssignmentList) {
    this.instanceServiceContainer.selectionService.setSelectedElements(null);
    return DomConverter.ConvertToString([...this.rootDesignItem.children()], designItemsAssignmentList);
  }

  async parseHTML(html) {
    this.rootDesignItem.element.innerHTML = null;
    this.instanceServiceContainer.undoService.clear();
    const parserService = this.serviceContainer.htmlParserService;
    const designItems = await parserService.parse(html, this.serviceContainer, this.instanceServiceContainer);

    this._addDesignItems(designItems);
  }

  _addDesignItems(designItems) {
    if (designItems) {
      for (let di of designItems) {
        this.rootDesignItem.element.append(di.element);
      }
    }

    const intializationService = this.serviceContainer.intializationService;

    if (intializationService) {
      for (let di of designItems) intializationService.init(di);
    }

    this.snapLines.clearSnaplines();
  }

  _onDragEnter(event) {
    event.preventDefault();
  }

  _onDragOver(event) {
    event.preventDefault();
    /*if (this.alignOnSnap) {
      this.snapLines.calculateSnaplines(this.instanceServiceContainer.selectionService.selectedElements);
      //todo fix this following code...
      const currentPoint = this.getDesignerMousepoint(event);
      let containerService = this.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(this.rootDesignItem))
      containerService.finishPlace(this, this.rootDesignItem, this._initialPoint, currentPoint, this.instanceServiceContainer.selectionService.selectedElements);
    }*/
  }

  async _onDrop(event) {
    event.preventDefault();

    this._fillCalculationrects();

    let transferData = event.dataTransfer.getData(dragDropFormatName);
    let elementDefinition = JSON.parse(transferData);
    let di = await this.serviceContainer.forSomeServicesTillResult("instanceService", service => service.getElement(elementDefinition, this.serviceContainer, this.instanceServiceContainer));
    let grp = di.openGroup("Insert");
    di.setStyle('position', 'absolute');
    const targetRect = event.target.getBoundingClientRect();
    di.setStyle('top', event.offsetY + targetRect.top - this.containerBoundingRect.y + 'px');
    di.setStyle('left', event.offsetX + targetRect.left - this.containerBoundingRect.x + 'px');
    this.instanceServiceContainer.undoService.execute(new InsertAction(this.rootDesignItem, this._canvas.children.length, di));
    grp.commit();
    this.instanceServiceContainer.selectionService.setSelectedElements([di]);
  }

  _onWheel(event) {
    if (event.ctrlKey) {
      event.preventDefault();
      this._zoomFactor += event.deltaY * -0.001; //deltamode = 0

      if (this._zoomFactor < 0.1) this._zoomFactor = 0.1;
      this.zoomFactorChanged(); //todo: scroll so we zoom on mouse position
    }
  }

  _onContextMenu(event) {
    event.preventDefault();
    this.showDesignItemContextMenu([], event);
  }

  showDesignItemContextMenu(designItem, event) {
    let mnuItems = [{
      title: 'copy',
      action: () => {
        this.executeCommand({
          type: CommandType.copy
        });
      }
    }, {
      title: 'cut',
      action: () => {
        this.executeCommand({
          type: CommandType.cut
        });
      }
    }, {
      title: 'paste',
      action: () => {
        this.executeCommand({
          type: CommandType.paste
        });
      }
    }, {
      title: '-'
    }, {
      title: 'delete',
      action: () => {
        this.executeCommand({
          type: CommandType.delete
        });
      }
    }, {
      title: '-'
    }, {
      title: 'to front',
      action: () => {
        this.executeCommand({
          type: CommandType.moveToFront
        });
      }
    }, {
      title: 'move forward',
      action: () => {
        this.executeCommand({
          type: CommandType.moveForward
        });
      }
    }, {
      title: 'move backward',
      action: () => {
        this.executeCommand({
          type: CommandType.moveBackward
        });
      }
    }, {
      title: 'to back',
      action: () => {
        this.executeCommand({
          type: CommandType.moveToBack
        });
      }
    }];

    if (designItem.length > 1) {//todo: special menu for multiple items?
    }

    let ctxMnu = ContextMenuHelper.showContextMenu(null, event, null, mnuItems);
    return ctxMnu;
  }

  onKeyUp(event) {
    switch (event.key) {
      case 'ArrowUp':
        this._resetPointerEventsForClickThrough();

        break;
    }

    event.preventDefault();
  }

  _resetPointerEventsForClickThrough() {
    if (this._clickThroughElements.length == 0) return;
    this._clickThroughElements = [];
  }

  onKeyDown(event) {
    // This is a global window handler, so clicks can come from anywhere
    // We only care about keys that come after you've clicked on an element,
    // or keys after you've selected something from the tree view.
    // TODO: can this be less bad since it's p horrid?

    /*let isOk =
      //@ts-ignore
      (event.composedPath()[0].localName === 'button' && event.composedPath()[2].localName == 'tree-view') ||
      //@ts-ignore
      (event.composedPath()[0].localName == 'body') || event.composedPath()[0].classList.contains(DesignerView._activeClassName);
    */
    if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) this.executeCommand({
      type: CommandType.undo
    });else if ((event.ctrlKey || event.metaKey) && event.key === 'z' && event.shiftKey) this.executeCommand({
      type: CommandType.redo
    });else if ((event.ctrlKey || event.metaKey) && event.key === 'y') this.executeCommand({
      type: CommandType.redo
    });else {
      let primarySelection = this.instanceServiceContainer.selectionService.primarySelection;

      if (!primarySelection) {
        return;
      }

      let moveOffset = 1;
      if (event.shiftKey) moveOffset = 10;

      switch (event.key) {
        case 'Delete':
        case 'Backspace':
          this.executeCommand({
            type: CommandType.delete
          });
          break;

        case 'ArrowUp':
          {
            this.instanceServiceContainer.selectionService.selectedElements.forEach(x => x.setStyle('top', parseInt(x.element.style.top) - moveOffset + 'px'));

            this._extensionManger.refreshExtensions(this.instanceServiceContainer.selectionService.selectedElements);
          }
          break;

        case 'ArrowDown':
          {
            this.instanceServiceContainer.selectionService.selectedElements.forEach(x => x.setStyle('top', parseInt(x.element.style.top) + moveOffset + 'px'));

            this._extensionManger.refreshExtensions(this.instanceServiceContainer.selectionService.selectedElements);
          }
          break;

        case 'ArrowLeft':
          {
            this.instanceServiceContainer.selectionService.selectedElements.forEach(x => x.setStyle('left', parseInt(x.element.style.left) - moveOffset + 'px'));

            this._extensionManger.refreshExtensions(this.instanceServiceContainer.selectionService.selectedElements);
          }
          break;

        case 'ArrowRight':
          {
            this.instanceServiceContainer.selectionService.selectedElements.forEach(x => x.setStyle('left', parseInt(x.element.style.left) + moveOffset + 'px'));

            this._extensionManger.refreshExtensions(this.instanceServiceContainer.selectionService.selectedElements);
          }
          break;
      }
    }
    event.preventDefault();
  }

  applyExtension() {}

  _selectedElementsChanged(selectionChangedEvent) {
    if (selectionChangedEvent.oldSelectedElements && selectionChangedEvent.oldSelectedElements.length) {
      const primaryContainer = DesignItem.GetOrCreateDesignItem(selectionChangedEvent.oldSelectedElements[0].parent.element, this.serviceContainer, this.instanceServiceContainer);

      this._extensionManger.removeExtension(primaryContainer, ExtensionType.PrimarySelectionContainer);

      this._extensionManger.removeExtension(selectionChangedEvent.oldSelectedElements[0], ExtensionType.PrimarySelection);

      this._extensionManger.removeExtensions(selectionChangedEvent.oldSelectedElements, ExtensionType.Selection);
    }

    if (selectionChangedEvent.selectedElements && selectionChangedEvent.selectedElements.length) {
      this._extensionManger.applyExtensions(selectionChangedEvent.selectedElements, ExtensionType.Selection);

      this._extensionManger.applyExtension(selectionChangedEvent.selectedElements[0], ExtensionType.PrimarySelection);

      const primaryContainer = DesignItem.GetOrCreateDesignItem(selectionChangedEvent.selectedElements[0].parent.element, this.serviceContainer, this.instanceServiceContainer);

      this._extensionManger.applyExtension(primaryContainer, ExtensionType.PrimarySelectionContainer);
    }

    this._extensionManger.refreshExtensions(selectionChangedEvent.selectedElements);
  }

  setSelectedElements(elements) {
    if (elements) {
      let diArray = [];

      for (let e of elements) {
        diArray.push(DesignItem.GetOrCreateDesignItem(e, this.serviceContainer, this.instanceServiceContainer));
      }

      this.instanceServiceContainer.selectionService.setSelectedElements(diArray);
    } else {
      this.instanceServiceContainer.selectionService.setSelectedElements(null);
    }
  }

  getDesignerMousepoint(event, target, startPoint) {
    let targetRect = target.getBoundingClientRect();
    return {
      originalX: event.x - this.containerBoundingRect.x,
      containerOriginalX: event.x - this._ownBoundingRect.x,
      x: (event.x - this.containerBoundingRect.x) / this._zoomFactor,
      originalY: event.y - this.containerBoundingRect.y,
      containerOriginalY: event.y - this._ownBoundingRect.y,
      y: (event.y - this.containerBoundingRect.y) / this._zoomFactor,
      controlOffsetX: startPoint ? startPoint.controlOffsetX : event.x - targetRect.x,
      controlOffsetY: startPoint ? startPoint.controlOffsetY : event.y - targetRect.y,
      zoom: this._zoomFactor
    };
  }

  _pointerEventHandler(event) {
    if (event.button == 2) return;
    let currentElement = this.shadowRoot.elementFromPoint(event.x, event.y);
    if (currentElement === this._outercanvas2 || currentElement === this.overlayLayer) currentElement = this._canvas;

    if (this.serviceContainer.tool) {
      this._canvas.style.cursor = this.serviceContainer.tool.cursor;
      this.serviceContainer.tool.pointerEventHandler(this, event, currentElement);
    } else {
      this._canvas.style.cursor = '';
      this.pointerEventHandlerElement(event, currentElement);
    }
  }

  _fillCalculationrects() {
    this._ownBoundingRect = this.getBoundingClientRect();
    this.containerBoundingRect = this._canvasContainer.getBoundingClientRect();
  }

  pointerEventHandlerElement(event, currentElement, forcedAction, actionMode) {
    var _a;

    if (event.type != EventNames.PointerUp && currentElement && currentElement.parentNode == this.overlayLayer) return;
    if (currentElement && currentElement.parentNode == this.overlayLayer) currentElement = (_a = this.instanceServiceContainer.selectionService.primarySelection.element) !== null && _a !== void 0 ? _a : this._canvas;

    switch (event.type) {
      case EventNames.PointerDown:
        event.target.setPointerCapture(event.pointerId);
        this._movedSinceStartedAction = false;
        break;

      case EventNames.PointerUp:
        event.target.releasePointerCapture(event.pointerId);
        break;
    }

    if (!event.altKey) this._resetPointerEventsForClickThrough();

    this._fillCalculationrects();

    if (!currentElement) return;
    const currentPoint = this.getDesignerMousepoint(event, currentElement, event.type === 'pointerdown' ? null : this._initialPoint);
    const currentDesignItem = DesignItem.GetOrCreateDesignItem(currentElement, this.serviceContainer, this.instanceServiceContainer); //const isCurrentItemSelected = this.instanceServiceContainer.selectionService.isSelected(currentDesignItem);

    if (this._actionType == null) {
      this._initialPoint = currentPoint;

      if (event.type == EventNames.PointerDown) {
        this._actionStartedDesignItem = currentDesignItem;
        this.snapLines.clearSnaplines();
        let composedPath = event.composedPath(); //let rectCurrentElement = currentElement.getBoundingClientRect();

        if (currentDesignItem !== this.rootDesignItem && forcedAction == PointerActionType.Drag
        /* this._forceMove({ x: currentPoint.containerOriginalX, y: currentPoint.containerOriginalY }, { x: rectCurrentElement.left - this._ownBoundingRect.left, y: rectCurrentElement.top - this._ownBoundingRect.top })*/
        ) {
            this._actionType = PointerActionType.Drag;
          } else if (composedPath && composedPath[0] === currentElement && (currentElement.children.length > 0 || currentElement.innerText == '') && currentElement.style.background == '' && currentElement.localName === 'div') {
          // todo: maybe check if some element in the composedPath till the designer div has a background. If not, selection mode
          this.setSelectedElements(null);
          this._actionType = PointerActionType.DrawSelection;
        } else if (currentElement === this || currentElement === this._canvas || currentElement == null) {
          this.setSelectedElements(null);
          this._actionType = PointerActionType.DrawSelection;
          return;
        } else {
          this._actionType = forcedAction !== null && forcedAction !== void 0 ? forcedAction : PointerActionType.DragOrSelect;
        }
      }
    }

    if (event.type === EventNames.PointerMove) {
      this._movedSinceStartedAction = this._movedSinceStartedAction || currentPoint.x != this._initialPoint.x || currentPoint.y != this._initialPoint.y;
      if (this._actionType == PointerActionType.DrawSelection) this._actionType = PointerActionType.DrawingSelection;
    }

    if (this._actionType == PointerActionType.DrawSelection || this._actionType == PointerActionType.DrawingSelection) {
      this._pointerActionTypeDrawSelection(event, currentElement, currentPoint);
    } else if (this._actionType == PointerActionType.Resize) {
      this._pointerActionTypeResize(event, currentElement, currentPoint, actionMode);
    } else if (this._actionType == PointerActionType.Rotate) {
      this._pointerActionTypeRotate(event, currentElement, currentPoint, actionMode);
    } else if (this._actionType == PointerActionType.DragOrSelect || this._actionType == PointerActionType.Drag) {
      this._pointerActionTypeDragOrSelect(event, currentDesignItem, currentPoint);
    }

    if (event.type == EventNames.PointerUp) {
      this.snapLines.clearSnaplines();

      if (this._actionType == PointerActionType.DrawSelection) {
        if (currentDesignItem !== this.rootDesignItem) this.setSelectedElements([currentElement]);
      }

      this._actionType = null;
      this._actionStartedDesignItem = null;
      this._movedSinceStartedAction = false;
      this._initialPoint = null;
    }

    this._previousEventName = event.type;
  }

  _pointerActionTypeDrawSelection(event, currentElement, currentPoint) {
    let ox1 = Math.min(this._initialPoint.containerOriginalX, currentPoint.containerOriginalX);
    let ox2 = Math.max(this._initialPoint.containerOriginalX, currentPoint.containerOriginalX);
    let oy1 = Math.min(this._initialPoint.containerOriginalY, currentPoint.containerOriginalY);
    let oy2 = Math.max(this._initialPoint.containerOriginalY, currentPoint.containerOriginalY);
    /*let ox1 = Math.min(this._initialPoint.x, currentPoint.x);
    let ox2 = Math.max(this._initialPoint.x, currentPoint.x);
    let oy1 = Math.min(this._initialPoint.y, currentPoint.y);
    let oy2 = Math.max(this._initialPoint.y, currentPoint.y);*/

    let selector = this._selector;
    selector.style.left = (ox1 + this._outercanvas2.scrollLeft) / this._zoomFactor + 'px';
    selector.style.top = (oy1 + this._outercanvas2.scrollTop) / this._zoomFactor + 'px';
    selector.style.width = (ox2 - ox1) / this._zoomFactor + 'px';
    selector.style.height = (oy2 - oy1) / this._zoomFactor + 'px';
    selector.hidden = false;

    if (event.type == EventNames.PointerUp) {
      selector.hidden = true;

      let elements = this._canvas.querySelectorAll('*');

      let inSelectionElements = [];

      for (let e of elements) {
        let elementRect = e.getBoundingClientRect();

        if (elementRect.top - this.containerBoundingRect.top >= oy1 + this._outercanvas2.scrollTop && elementRect.left - this.containerBoundingRect.left >= ox1 + this._outercanvas2.scrollLeft && elementRect.top - this.containerBoundingRect.top + elementRect.height <= oy2 + this._outercanvas2.scrollTop && elementRect.left - this.containerBoundingRect.left + elementRect.width <= ox2 + this._outercanvas2.scrollLeft) {
          inSelectionElements.push(e);
        }
      }

      this.setSelectedElements(inSelectionElements);
    }
  }

  _pointerActionTypeDragOrSelect(event, currentDesignItem, currentPoint) {
    if (event.altKey) {
      let backup = [];
      if (event.type == EventNames.PointerDown) this._clickThroughElements.push(currentDesignItem);

      for (const e of this._clickThroughElements) {
        backup.push(e.element.style.pointerEvents);
        e.element.style.pointerEvents = 'none';
      }

      let currentElement = this.shadowRoot.elementFromPoint(event.x, event.y);
      currentDesignItem = DesignItem.GetOrCreateDesignItem(currentElement, this.serviceContainer, this.instanceServiceContainer);

      for (const e of this._clickThroughElements) {
        e.element.style.pointerEvents = backup.shift();
      }
    } else {
      this._clickThroughElements = [];
    }
    /*let trackX = currentPoint.x - this._initialPoint.x;
    let trackY = currentPoint.y - this._initialPoint.y;
    if (event.type !== EventNames.PointerDown) {
      if (this._alignOnGrid) {
        trackX = Math.round(trackX / this._gridSize) * this._gridSize;
        trackY = Math.round(trackY / this._gridSize) * this._gridSize;
      }
      else if (this._alignOnSnap) {
        //let rect = this.instanceServiceContainer.selectionService.primarySelection.element.getBoundingClientRect();
        let newPos = this._snaplines.snapToPosition({ x: currentPoint.x, y: currentPoint.y }, { x: 0, y: 0 })
        trackX = newPos.x - this._initialPoint.x;
        trackY = newPos.y - this._initialPoint.y;
      }
    }*/


    switch (event.type) {
      case EventNames.PointerDown:
        {
          this._actionStartedDesignItem = currentDesignItem;
          this._dropTarget = null;

          if (event.shiftKey || event.ctrlKey) {
            const index = this.instanceServiceContainer.selectionService.selectedElements.indexOf(currentDesignItem);

            if (index >= 0) {
              let newSelectedList = this.instanceServiceContainer.selectionService.selectedElements.slice(0);
              newSelectedList.splice(index, 1);
              this.instanceServiceContainer.selectionService.setSelectedElements(newSelectedList);
            } else {
              let newSelectedList = this.instanceServiceContainer.selectionService.selectedElements.slice(0);
              newSelectedList.push(currentDesignItem);
              this.instanceServiceContainer.selectionService.setSelectedElements(newSelectedList);
            }
          } else {
            if (this.instanceServiceContainer.selectionService.selectedElements.indexOf(currentDesignItem) < 0) this.instanceServiceContainer.selectionService.setSelectedElements([currentDesignItem]);
          }

          if (this.alignOnSnap) this.snapLines.calculateSnaplines(this.instanceServiceContainer.selectionService.selectedElements);
          break;
        }

      case EventNames.PointerMove:
        {
          const elementMoved = currentPoint.x != this._initialPoint.x || currentPoint.y != this._initialPoint.y;

          if (this._actionType != PointerActionType.Drag && elementMoved) {
            this._actionType = PointerActionType.Drag;
          } //if (this._actionType != PointerActionType.Drag)
          //  return;


          if (this._movedSinceStartedAction) {
            const containerService = this.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(this._actionStartedDesignItem.parent));
            containerService.place(event, this, this._actionStartedDesignItem.parent, this._initialPoint, currentPoint, this.instanceServiceContainer.selectionService.selectedElements);

            this._extensionManger.refreshExtensions(this.instanceServiceContainer.selectionService.selectedElements);
          } //todo -> what is if a transform already exists -> backup existing style.?

          /*for (const designItem of this.instanceServiceContainer.selectionService.selectedElements) {
            (<HTMLElement>designItem.element).style.transform = 'translate(' + trackX + 'px, ' + trackY + 'px)';
          }
                       // See if it's over anything.
          this._dropTarget = null;
          let targets = this._canvas.querySelectorAll('*');
          for (let i = 0; i < targets.length; i++) {
            let possibleTarget = targets[i] as HTMLElement;
            possibleTarget.classList.remove('over');
                         let possibleTargetDesignItem = DesignItem.GetOrCreateDesignItem(possibleTarget, this.serviceContainer, this.instanceServiceContainer);
            if (this.instanceServiceContainer.selectionService.selectedElements.indexOf(possibleTargetDesignItem) >= 0)
              continue;
                         // todo put following a extenable function ...
            // in IContainerHandler ...
                         // Only some native elements and things with slots can be drop targets.
            let slots = possibleTarget ? possibleTarget.querySelectorAll('slot') : [];
            // input is the only native in this app that doesn't have a slot
            let canDrop = (possibleTarget.localName.indexOf('-') === -1 && possibleTarget.localName !== 'input') || possibleTarget.localName === 'dom-repeat' || slots.length !== 0;
                         if (!canDrop) {
              continue;
            }
                         // Do we actually intersect this child?
            const possibleTargetRect = possibleTarget.getBoundingClientRect();
            if (possibleTargetRect.top - this._ownBoundingRect.top <= currentPoint.y &&
              possibleTargetRect.left - this._ownBoundingRect.left <= currentPoint.x &&
              possibleTargetRect.top - this._ownBoundingRect.top + possibleTargetRect.height >= currentPoint.y &&
              possibleTargetRect.left - this._ownBoundingRect.left + possibleTargetRect.width >= currentPoint.x) {
                           // New target! Remove the other target indicators.
              var previousTargets = this._canvas.querySelectorAll('.over');
              for (var j = 0; j < previousTargets.length; j++) {
                previousTargets[j].classList.remove('over');
              }
              if (currentDesignItem != possibleTargetDesignItem && this._dropTarget != possibleTarget) {
                possibleTarget.classList.add('over');
                             if (event.altKey) {
                  if (this._dropTarget != null)
                    this._dropTarget.classList.remove('over-enter');
                  this._dropTarget = possibleTarget;
                  this._dropTarget.classList.remove('over');
                  this._dropTarget.classList.add('over-enter');
                }
              }
            }
          }*/


          break;
        }

      case EventNames.PointerUp:
        {
          if (this._actionType == PointerActionType.DragOrSelect) {
            if (this._previousEventName == EventNames.PointerDown && !event.shiftKey && !event.ctrlKey) this.instanceServiceContainer.selectionService.setSelectedElements([currentDesignItem]);
            return;
          }

          if (this._movedSinceStartedAction) {
            let cg = this.rootDesignItem.openGroup("Move Elements", this.instanceServiceContainer.selectionService.selectedElements);
            let containerService = this.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(this._actionStartedDesignItem.parent));
            containerService.finishPlace(event, this, this._actionStartedDesignItem.parent, this._initialPoint, currentPoint, this.instanceServiceContainer.selectionService.selectedElements);
            cg.commit();
          }

          this._extensionManger.refreshExtensions(this.instanceServiceContainer.selectionService.selectedElements);

          break; //todo this needs also to get info from container handler, cause position is dependent of container

          for (const designItem of this.instanceServiceContainer.selectionService.selectedElements) {
            let movedElement = designItem.element;

            if (this._dropTarget && this._dropTarget != movedElement.parentElement) {
              //let oldParent = movedElement.parentElement;
              movedElement.parentElement.removeChild(currentDesignItem.element); // If there was a textContent nuke it, or else you'll
              // never be able to again.

              /*if (this._dropTarget.children.length === 0) {
                this._dropTarget.textContent = '';
              }
              this._dropTarget.appendChild(currentElement);
                               this.actionHistory.add(ActionHistoryType.Reparent, currentElement,
                {
                  new: {
                    parent: this._dropTarget,
                    left: currentElement.style.left, top: currentElement.style.top, position: currentElement.style.position
                  },
                  old: {
                    parent: oldParent,
                    left: oldLeft, top: oldTop, position: oldPosition
                  }
                });*/
            } else {
              let oldLeft = parseInt(movedElement.style.left);
              oldLeft = Number.isNaN(oldLeft) ? 0 : oldLeft;
              let oldTop = parseInt(movedElement.style.top);
              oldTop = Number.isNaN(oldTop) ? 0 : oldTop; //let oldPosition = movedElement.style.position;
              //todo: move this to handler wich is specific depeding on the container (e.g. canvasHandler, gridHandler, flexboxHandler...)
              //todo: designitem set properties undo...

              designItem.element.style.transform = null;
              designItem.setStyle('position', 'absolute'); //designItem.setStyle('left', (trackX + oldLeft) + "px");
              //designItem.setStyle('top', (trackY + oldTop) + "px");
              //todo

              /*this.serviceContainer.UndoService.add(UndoItemType.Move, movedElement,
                {
                  new: { left: movedElement.style.left, top: movedElement.style.top, position: movedElement.style.position },
                  old: { left: oldLeft, top: oldTop, position: oldPosition }
                });*/
            } //cg.commit();


            if (this._dropTarget != null) this._dropTarget.classList.remove('over-enter');
            this._dropTarget = null;
          }
          /* let oldParent = currentElement.parentElement;
           let newParent;
           // Does this need to be added to a new parent?
           if (this._dropTarget) {
             reparented = true;
             oldParent.removeChild(currentElement);
                           // If there was a textContent nuke it, or else you'll
             // never be able to again.
             if (this._dropTarget.children.length === 0) {
               this._dropTarget.textContent = '';
             }
             this._dropTarget.appendChild(currentElement);
             newParent = this._dropTarget;
             this._dropTarget = null;
           } else if (currentElement.parentElement && (currentElement.parentElement !== this._canvas)) {
             reparented = true;
             // If there's no drop target and the el used to be in a different
             // parent, move it to the main view.
             newParent = this._canvas;
             currentElement.parentElement.removeChild(currentElement);
             this.add(currentElement);
           }
           let parent = currentElement.parentElement.getBoundingClientRect();
                         let oldLeft = currentElement.style.left;
           let oldTop = currentElement.style.top;
           let oldPosition = currentElement.style.position;
           if (reparented) {
             currentElement.style.position = 'relative';
             currentElement.style.left = currentElement.style.top = '0px';
             this.actionHistory.add(ActionHistoryType.Reparent, currentElement,
               {
                 new: {
                   parent: newParent,
                   left: currentElement.style.left, top: currentElement.style.top, position: currentElement.style.position
                 },
                 old: {
                   parent: oldParent,
                   left: oldLeft, top: oldTop, position: oldPosition
                 }
               });
           } else {
             currentElement.style.position = 'absolute';
             currentElement.style.left = rekt.left - parent.left + 'px';
             currentElement.style.top = rekt.top - parent.top + 'px';
             this.actionHistory.add(ActionHistoryType.Move, el,
               {
                 new: { left: currentElement.style.left, top: currentElement.style.top, position: currentElement.style.position },
                 old: { left: oldLeft, top: oldTop, position: oldPosition }
               });
           }
                         if (newParent)
             newParent.classList.remove('over');
           if (oldParent)
             oldParent.classList.remove('over');
           currentElement.classList.remove('dragging');
           currentElement.classList.remove('resizing');
           currentElement.style.transform = 'none'; */


          break;
        }
    } //todo this.dispatchEvent(new CustomEvent('refresh-view', { bubbles: true, composed: true, detail: { whileTracking: true, node: this } }));

  }

  _pointerActionTypeResize(event, currentElement, currentPoint, actionMode = 'se-resize') {
    switch (event.type) {
      case EventNames.PointerDown:
        this._initialSizes = [];
        this._actionModeStarted = actionMode;

        for (const designItem of this.instanceServiceContainer.selectionService.selectedElements) {
          let rect = designItem.element.getBoundingClientRect();

          this._initialSizes.push({
            width: rect.width,
            height: rect.height
          });
        }

        if (this.alignOnSnap) this.snapLines.calculateSnaplines(this.instanceServiceContainer.selectionService.selectedElements);
        break;

      case EventNames.PointerMove:
        this._initialPoint.controlOffsetX = 0;
        this._initialPoint.controlOffsetY = 0;
        const containerService = this.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(this._actionStartedDesignItem.parent));
        const diff = containerService.placePoint(event, this, this._actionStartedDesignItem.parent, this._initialPoint, currentPoint, this.instanceServiceContainer.selectionService.selectedElements);
        let trackX = diff.x - this._initialPoint.x;
        let trackY = diff.y - this._initialPoint.y;
        let i = 0;

        switch (this._actionModeStarted) {
          case 'se-resize':
            for (const designItem of this.instanceServiceContainer.selectionService.selectedElements) {
              designItem.element.style.width = this._initialSizes[i].width + trackX + 'px';
              designItem.element.style.height = this._initialSizes[i].height + trackY + 'px';
            }

            break;

          case 's-resize':
            for (const designItem of this.instanceServiceContainer.selectionService.selectedElements) {
              designItem.element.style.height = this._initialSizes[i].height + trackY + 'px';
            }

            break;

          case 'e-resize':
            for (const designItem of this.instanceServiceContainer.selectionService.selectedElements) {
              designItem.element.style.width = this._initialSizes[i].width + trackX + 'px';
            }

            break;
          //for other resize modes we need a replacement
        }

        this._extensionManger.refreshExtensions(this.instanceServiceContainer.selectionService.selectedElements);

        break;

      case EventNames.PointerUp:
        let cg = this.rootDesignItem.openGroup("Resize Elements", this.instanceServiceContainer.selectionService.selectedElements);

        for (const designItem of this.instanceServiceContainer.selectionService.selectedElements) {
          designItem.setStyle('width', designItem.element.style.width);
          designItem.setStyle('height', designItem.element.style.height);
        }

        cg.commit();
        this._initialSizes = null;
        break;
    }
  }

  _pointerActionTypeRotate(event, currentElement, currentPoint, actionMode = 'se-resize') {
    switch (event.type) {
      case EventNames.PointerDown:
        this._actionModeStarted = actionMode;
        break;

      case EventNames.PointerMove:
        //let trackX = currentPoint.x - this._initialPoint.x;
        //let trackY = currentPoint.y - this._initialPoint.y;
        //let i = 0;

        /*
                var center_x = (offset.left) + (img.width() / 2);
            var center_y = (offset.top) + (img.height() / 2);
            var mouse_x = evt.pageX;
            var mouse_y = evt.pageY;
            var radians = Math.atan2(mouse_x - center_x, mouse_y - center_y);
            var degree = (radians * (180 / Math.PI) * -1) + 90;
            img.css('-moz-transform', 'rotate(' + degree + 'deg)');*/
        this._extensionManger.refreshExtensions(this.instanceServiceContainer.selectionService.selectedElements);

        break;

      case EventNames.PointerUp:
        let cg = this.rootDesignItem.openGroup("Resize Elements", this.instanceServiceContainer.selectionService.selectedElements);
        /*for (const designItem of this.instanceServiceContainer.selectionService.selectedElements) {
          designItem.setStyle('width', (<HTMLElement>designItem.element).style.width);
          designItem.setStyle('height', (<HTMLElement>designItem.element).style.height);
        }*/

        cg.commit();
        this._initialSizes = null;
        break;
    }
  }

}
DesignerView.style = css`
    :host {
      display: block;
      box-sizing: border-box;
      width: 100%;
      position: relative;
      transform: translateZ(0);
      overflow: hidden;
    }
    * {
      touch-action: none;
    }
    #canvasContainer {
      width: 100%;
      height: 100%;
      margin: auto;
      position: absolute;
      top: 0;
      /* bottom: 0; does not work with fixed sized when size is bigger then view */
      left: 0;
      /* right: 0; */
    }
    #canvas {
      background-color: var(--canvas-background, white);
      /* 10px grid, using http://www.patternify.com/ */
      background-image: url(data:image/png;base64,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);
      background-position: 0px 0px;
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      transform-origin: 0 0;
    }

    #svg {
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      overflow: visible;
    }
    .svg-snapline { stroke: purple; stroke-dasharray: 4; fill: transparent; }
    .svg-selection { stroke: #3899ec; fill: transparent; stroke-width: 2; }
    .svg-primary-selection-move { stroke: #3899ec; fill: #3899ec; cursor: move; pointer-events: all }
    .svg-text { stroke: none; fill: white; stroke-width: 1; font-size: 10px; font-family: monospace; }
    .svg-primary-resizer { stroke: #3899ec; fill: white; pointer-events: all }
    .svg-primary-rotate { stroke: #3899ec; fill: #3899ec; pointer-events: all }
    .svg-grid { stroke: orange; stroke-dasharray: 5; fill: #ff944722; }
    .svg-grid-area { font-size: 8px; }
    .svg-grid-gap { stroke: orange; stroke-dasharray: 5; fill: #0000ff22; }
    .svg-transform-origin { stroke: #3899ec; fill: black; pointer-events: all }
    .svg-margin { fill: #ff944722; }
    .svg-position  { stroke: black; stroke-dasharray: 2; }
  
    #canvas * {
      cursor: pointer;
      user-select: none;
    }
    #canvas *:not(.node-projects-wcdesigner-active):hover {
      outline: solid 2px #90CAF9 !important;
      outline-offset: 2px;
    }
    :host(.node-projects-wcdesigner-active) {
      outline-offset: -3px;
    }
    #selector {
      border: 1px dotted #000;
      position: absolute;
      pointer-events: none;
    }
    .lowertoolbar {
      height: 16px;
      background: #787f82;
      display: flex;
    }
    input {
      width: 40px;
      height: 16px;
      padding: 0;
      border: 0;
      font-size: 12px;
      text-align: center;
      margin-right: 1px;
    }
    .toolbar-control {
      width: 16px;
      height: 16px;
      display: block;
      margin-right: 1px;
      cursor: default;
    }
    .toolbar-control:hover {
      background-color:rgba(164,206,249,.6);
    }
    .outer {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    #outercanvas1 {
      width: 100%;
      height: calc(100% - 17px);
    }
    #outercanvas2 {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: auto;
    }

    .over {
      outline: dashed 3px var(--highlight-green, #99ff33) !important;
      outline-offset: 2px;
    }
    .over::before {
      content: 'press "alt" to enter container';
      top: 5px;
      left: 5px;
      position: absolute;
      opacity: 0.5;
    }
    .over-enter {
      outline: solid 3px var(--highlight-green, #99ff33) !important;
      outline-offset: 2px;
    }
  
    .zoom-in {
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAn9JREFUeNqkU11o01AUTtI06U/6tzHWbnNVS+k67FAG/gwfZEOcCrpNEBwEH2Q+Otqxh+5VEaHYV18UwQd9sk4Q+6CUKogbtSoM10qftJS2iGuT/iRpshvvDZu4DHHggY+TnHu+795zz7m4qqrYxfA6pjerlcHMZvMQQRCL8Hccoh+iBJECAMQEQci3Wk2MxP5iqgqmJUmIB3xkdTRoKgQG6Wr1JxBX1oTQx3UxCdcjMO2ZJiCK4g4y3HUIACV+bsL5dSRAWfwe636z0WBzWEFzn5vku5xyIZGsx2UF5AhEaDYbO8Dz3KLPi1X9B2iTy0pRiDx5/Z2bJgmGwDH8WMhuDxzEf6A8TYDneT3GR4JMzcVQThNlcCtANaM48pICutodxXTkkI1HeVslSPor6B/wWL7B3Z1n2KR3O3h05rkDOkd2eYoSxM025PVrAgAQeoFSuSLI3Q66jpJNRsIWPLvM5JJTTUkGGsqVtgJ5JU3AaLTqBVKZT9xh7yDT2Gh05G4bNQBzGETkBbkMVAxbzdadMJbSBDzCHXgKgKGZQJCp0IP32dnEaKhd6nOZAay7mXk6UUGeIHDDh88NKb0qumjaHiN391/1GjtrJ6ZPSb33H9eJYomuTJ601Qf7SKVYVlqplZblxRvOThrtEaC28qSOPAwncCYSWbzJsrO3XP4br9KZa1fTmcaOSTQYLDFFaeURh/yDfLynp/fCwkI0yrKX79ZqG49sUr2A44a3u+d08/fXVhfAeZ8vcDocjs6z7KV7xeL3JzBcwPZgmoAkScGlpdvzc3NXHuZyXxIwlMX2aJoAfFkvx8aGnRzH5WEpr7cXuerKPwVw1Lb/sV8CDACbf0U37X3NqwAAAABJRU5ErkJggg==);
    }
    .zoom-out {
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAmVJREFUeNqkU01oE0EUnv3Nf0xsS01jEzWUNCUplh7U4kEiVVEQqyBYWDxor5am5JBeFRGCuXpRBA8KHqIHMYISohdTYlQo2kguaghJUNvd/O1udjvr7NKWZHuw4IMHM/v9zHu8t5iiKCAYDAKi/xQ4MHEdbIXFYgUmk2kUx/EouoZRulGWUaYhhHGe5wutVhOQKtk3/RToQ1HgjCjyCb+PrE0GjEW/x1Cr/YFCdoUPffwqpBAeQbRnmoEgCD1i9OoohHLi7EnHt3E/bfb0m/pwDGBeF04P77Mpex1SMZliE5IMV3FV0Gw2erJe56I+L6iNHDQYnRaaVsXb5uh8JGS3+w9hv1SeVkG9Xtd3EB4PDBecVtplpAmHKMMesN2R2Ymg7fer9PfwZgui3sC932X+gV53nGZSXj2Yf36B5oWNNtK5NQMIcT2nXKnyUt8eA6uSUf1YNyhKsFmptmWkK2sGFGXRG6Rzn7jDXo+1sdboSBSJEd0gVABYzrMOpEtrBi7+DqoCAnUn1JTo0IP3+dnkZKhdHnKaIEUSXRPCiA+fG2JmWXAaDPY4uXP+ipfqrBybOSEO3n/M4qWyoXrmuE30DJHWUkVupbMt44u3nJ2k7BGotAqkTjyGNvBiJBK9yTCzt5wjN15ncteuZnKNnk0kCHNcllsFVUN2iY8ODAyeX1yMxRjm8t319bVHNpEtYhjxbseago3t0+YU4Dmfzz+9sBCbZ5hL90qln0/Q5yLYRWgGoigGlpZuz8/NXXm4uvolqY4a7DI0A/RnvZyaGnNwHFdArbzZArla9p8GmDq2/4m/AgwATHQSD48kJDUAAAAASUVORK5CYII=);
    }
    .snap-grid {
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAblJREFUeNqkUjtLA0EQnntFyKNKJdiFgIlGC5G0FlaaIsYgiKAgKIKdjbV/wM7GImBhI6JFMFWKK3yBimBAhJDuUEgimMSYS0hunbncHRtFjLjw7X7z7ezszM4KjDEQRRG+jnlEgvYAAgLAJpoT1tYdA9gzAAqLuC/DD4N1EZC87v1IYnZ0MBj0k/6Szw/nTs7GO+8f62gWBCuDHTRG+ABxgGScsd3JlYWlJogu9TSjkT41NzM0AEbr5uDocJmxLTv3CCJpgbRkAKcWpq14vP7scVqrVKsbBOKktayS7BL4RzB5uxvAo7++SfV6vYnmBenESaM9/qCESFt4pPUJJzrlLpe/vQ9pTeex8A0EQcggwILJo9EohMPhNVW9ZqFQaJvsWCzWozGuCxJ3gck1TYNGo+Hy+XxQKpXalUoFisUi1Go1RyM/uwtZLsADYkxRlGnMZLXT6QQkSSqglsIV0HY0XddTdgkqV4LD6YPJsgwYzLSJEygQraz70YDvRg9Hh3O8DdptM1uTEwzDMDnvTHVfWfy+D8592W4Jt1wJfXOnC0h8XMw/cbuEHOKZc/iNX9qC2cb/jE8BBgAvhdOb37HVsgAAAABJRU5ErkJggg==);
    }
    .snap-guide {
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAYVJREFUeNqkU7tKA1EQnbs3CnlVqbQNARMjFilS+AnZQhIbW0ER/AA/wlYbhXR2wUKx0iKNYGMKDViEdEIgieBujGvCPpyz7sK6iWLIwJk798zsuXsfIxzHoXksAqcoij+vMbYq7MoszGxaEB3wtODlH3i5E5uojck210RCgq7SJie4MC0TsdO1cim/lMmkwHdarZWni+t16/1jz/FElJBAGc5imLzyakXNG0IuVo+OnwHE4JCzgisG7BJu/I3CQjyRuq1dvWi6vg8gBofcOHgGAZO+AFv88/VNDofDEcd3IBCD43ycfhEowY28Sazfnzh1cKMggWsUQvi4waiqKuVyud16/d7JZrOHxWJxKudMuQV3C81mk3RdX0wmk9Tr9UxN06jb7dJgMPjBwQRUAu/AtWg0SpZl7TDSUso2/1UVNWHOMIwJARzWBhcQwMXu1oJb9Ufbtsk0zYktPLrvgD8E/mWeYoNxxlj2xoZ3qI2/YrePQs10PksjTRPozCog5m3nLwEGABrLzseuHT6IAAAAAElFTkSuQmCC);
    }
  }`;
DesignerView.template = html`
        <div class="outer">
          <div id="outercanvas1">
            <div id="outercanvas2">
              <div id="canvasContainer">
                <!-- <div id="zoomHelper" style="width: 10px; height: 10px; position: absolute; top: 0; left: 0; pointer-events: none;"></div> -->
                <div id="canvas" tabindex="0"></div>
                <div id="selector" hidden></div>
                <svg id="svg" style="pointer-events: none;"></svg>
              </div>
            </div>
          </div>
          <div class="lowertoolbar">
            <input id="zoomInput" type="text" value="100%">
            <div title="decrease zoom" id="zoomIncrease" class="toolbar-control zoom-in"></div>
            <div title="increase zoom" id="zoomDecrease" class="toolbar-control zoom-out"></div>
            <div title="reset zoom" id="zoomReset" class="toolbar-control"
              style="width: 16px; height: 16px; font-size: 14px; display: flex; align-items: center; justify-content: center;">1
            </div>
            <div title="zoom to fit" id="zoomFit" class="toolbar-control"
              style="width: 16px; height: 16px; font-size: 8px; display: flex; align-items: center; justify-content: center;">
              100%</div>
            <div title="snap to grid" id="alignGrid" class="toolbar-control snap-grid"></div>
            <div title="snap to elements" id="alignSnap" class="toolbar-control snap-guide"></div>
          </div>
        </div>
          `;
customElements.define('node-projects-designer-view', DesignerView);