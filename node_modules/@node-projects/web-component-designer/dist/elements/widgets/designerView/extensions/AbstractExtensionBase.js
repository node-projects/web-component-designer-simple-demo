import { OverlayLayer } from './OverlayLayer.js';
export class AbstractExtensionBase {
    overlays = [];
    overlayLayerView;
    extensionManager;
    designerCanvas;
    constructor(extensionManager, designerCanvas) {
        this.extensionManager = extensionManager;
        this.designerCanvas = designerCanvas;
        this.overlayLayerView = designerCanvas.overlayLayer;
    }
    _backup;
    _valuesHaveChanges(...values) {
        if (this._backup == null) {
            this._backup = values;
            return true;
        }
        for (let i = 0; i < values.length; i++) {
            if (values[i] !== this._backup[i]) {
                this._backup = values;
                return true;
            }
        }
        return false;
    }
    _removeAllOverlays() {
        for (let o of this.overlays) {
            try {
                this.overlayLayerView.removeOverlay(o);
            }
            catch (err) {
                console.error(err);
            }
        }
        this.overlays = [];
    }
    _addOverlay(element, overlayLayer = OverlayLayer.Normal) {
        this.overlayLayerView.addOverlay(this.constructor.name, element, overlayLayer);
        this.overlays.push(element);
    }
    _drawGroup(className, group, overlayLayer) {
        const newGroup = this.overlayLayerView.drawGroup(this.constructor.name, className, group, overlayLayer);
        if (!group) {
            this.overlays.push(newGroup);
        }
        return newGroup;
    }
    _drawLine(x1, y1, x2, y2, className, line, overlayLayer) {
        const newLine = this.overlayLayerView.drawLine(this.constructor.name, x1, y1, x2, y2, className, line, overlayLayer);
        if (!line) {
            this.overlays.push(newLine);
        }
        return newLine;
    }
    _drawCircle(x, y, radius, className, circle, overlayLayer) {
        const newCircle = this.overlayLayerView.drawCircle(this.constructor.name, x, y, radius, className, circle, overlayLayer);
        if (!circle) {
            this.overlays.push(newCircle);
        }
        return newCircle;
    }
    _drawRect(x, y, w, h, className, rect, overlayLayer) {
        const newRect = this.overlayLayerView.drawRect(this.constructor.name, x, y, w, h, className, rect, overlayLayer);
        if (!rect) {
            this.overlays.push(newRect);
        }
        return newRect;
    }
    _drawComplexRect(points, className, rect, overlayLayer) {
        const d = "M" + points.map(x => x.x + ',' + x.y).join(' ') + 'Z';
        const newRect = this.overlayLayerView.drawPath(this.constructor.name, d, className, rect, overlayLayer);
        if (!rect) {
            this.overlays.push(newRect);
        }
        return newRect;
    }
    _drawPath(data, className, path, overlayLayer) {
        const newPath = this.overlayLayerView.drawPath(this.constructor.name, data, className, path, overlayLayer);
        if (!path) {
            this.overlays.push(newPath);
        }
        return newPath;
    }
    _drawText(text, x, y, className, textEl, overlayLayer) {
        const newText = this.overlayLayerView.drawText(this.constructor.name, text, x, y, className, textEl, overlayLayer);
        if (!textEl) {
            this.overlays.push(newText);
        }
        return newText;
    }
    _drawHTML(html, x, y, w, h, className, htmlObj, overlayLayer) {
        const newHtml = this.overlayLayerView.drawHTML(this.constructor.name, html, x, y, w, h, className, htmlObj, overlayLayer);
        if (!htmlObj) {
            this.overlays.push(newHtml);
        }
        return newHtml;
    }
    _drawTextWithBackground(text, x, y, backgroundColor, className, existingEls, overlayLayer) {
        const newEls = this.overlayLayerView.drawTextWithBackground(this.constructor.name, text, x, y, backgroundColor, className, existingEls, overlayLayer);
        if (!existingEls) {
            this.overlays.push(...newEls);
        }
        return newEls;
    }
    _drawTransformedRect(points, className, path, overlayLayer) {
        let data = "M" + points[0].x + " " + points[0].y + " L" + points[1].x + " " + points[1].y + " L" + points[3].x + " " + points[3].y + " L" + points[2].x + " " + points[2].y + "Z";
        const newPath = this.overlayLayerView.drawPath(this.constructor.name, data, className, path, overlayLayer);
        if (!path) {
            this.overlays.push(newPath);
        }
        return newPath;
    }
}
