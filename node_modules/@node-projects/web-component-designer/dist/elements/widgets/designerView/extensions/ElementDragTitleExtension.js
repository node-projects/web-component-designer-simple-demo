import { getTextWidth } from '../../../helper/TextHelper.js';
import { getDesignerCanvasNormalizedTransformedCornerDOMPoints } from '../../../helper/TransformHelper.js';
import { NamedTools } from "../tools/NamedTools.js";
import { AbstractExtension } from './AbstractExtension.js';
const extensionWidth = 60;
export class ElementDragTitleExtension extends AbstractExtension {
    _rect;
    _clickRect;
    _text;
    _width;
    constructor(extensionManager, designerView, extendedItem) {
        super(extensionManager, designerView, extendedItem);
    }
    extend(cache, event) {
        const transformedCornerPoints = getDesignerCanvasNormalizedTransformedCornerDOMPoints(this.extendedItem.element, null, this.designerCanvas, cache);
        if (!isNaN(transformedCornerPoints[0].x)) {
            const boundRect = this.extendedItem.element.getBoundingClientRect();
            let w = getTextWidth(this.extendedItem.name, '10px monospace');
            let elementWidth = Math.sqrt(Math.pow(transformedCornerPoints[1].x - transformedCornerPoints[0].x, 2) + Math.pow(transformedCornerPoints[1].y - transformedCornerPoints[0].y, 2));
            let text = this.extendedItem.name;
            if (this.extendedItem.id)
                text = '#' + this.extendedItem.id;
            this._width = Math.max(Math.min(elementWidth, w), extensionWidth);
            this._rect = this._drawRect(transformedCornerPoints[0].x, transformedCornerPoints[0].y, this._width, 15, 'svg-primary-selection-move', this._rect);
            this._clickRect = this._drawRect(transformedCornerPoints[0].x, transformedCornerPoints[0].y, this._width, 18, 'svg-invisible', this._clickRect);
            this._clickRect.style.background = 'transparent';
            this._text = this._drawHTML('<div style="position:relative; pointer-events: none;"><span style="width: 100%; position: absolute; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; transform-origin: 0 0; padding-left: 2px;">' + text + '</span></div>', (boundRect.x - this.designerCanvas.containerBoundingRect.x) / this.designerCanvas.scaleFactor, transformedCornerPoints[0].y - 16, this._width, 15, 'svg-text-primary', this._text);
            this._text.style.overflow = 'visible';
            this._clickRect.addEventListener('pointerdown', (e) => this._pointerEvent(e));
            this._clickRect.addEventListener('pointermove', (e) => this._pointerEvent(e));
            this._clickRect.addEventListener('pointerup', (e) => this._pointerEvent(e));
            this._clickRect.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                this.designerCanvas.showDesignItemContextMenu(this.extendedItem, e);
            });
            this.refresh(cache, event);
        }
    }
    _drawMoveOverlay(itemRect) {
    }
    refresh(cache, event) {
        const transformedCornerPoints = getDesignerCanvasNormalizedTransformedCornerDOMPoints(this.extendedItem.element, { x: 0, y: 16 }, this.designerCanvas, cache);
        const angle = Math.atan2((transformedCornerPoints[1].y - transformedCornerPoints[0].y), (transformedCornerPoints[1].x - transformedCornerPoints[0].x)) * 180 / Math.PI;
        if (!isNaN(transformedCornerPoints[0].x)) {
            if (this._valuesHaveChanges(transformedCornerPoints[0].x, transformedCornerPoints[0].y, angle, this.designerCanvas.scaleFactor)) {
                const h = (15 / this.designerCanvas.scaleFactor);
                const w = (this._width / this.designerCanvas.scaleFactor);
                this._rect.setAttribute('x', '' + transformedCornerPoints[0].x);
                this._rect.setAttribute('y', '' + transformedCornerPoints[0].y);
                this._rect.style.rotate = angle + 'deg';
                this._rect.style.transformBox = 'fill-box';
                this._rect.setAttribute('height', '' + h);
                this._rect.setAttribute('width', '' + w);
                this._rect.style.strokeWidth = (1 / this.designerCanvas.scaleFactor).toString();
                this._clickRect.setAttribute('x', '' + transformedCornerPoints[0].x);
                this._clickRect.setAttribute('y', '' + transformedCornerPoints[0].y);
                this._clickRect.style.rotate = angle + 'deg';
                this._clickRect.style.transformBox = 'fill-box';
                this._clickRect.setAttribute('height', '' + (h + 3));
                this._clickRect.setAttribute('width', '' + w);
                this._clickRect.style.strokeWidth = (1 / this.designerCanvas.scaleFactor).toString();
                this._text.setAttribute('x', '' + transformedCornerPoints[0].x);
                this._text.setAttribute('y', '' + transformedCornerPoints[0].y);
                this._text.style.fontSize = (10 / this.designerCanvas.scaleFactor) + 'px';
                this._text.setAttribute('height', '' + h);
                this._text.setAttribute('width', '' + w);
                this._text.children[0].children[0].style.rotate = angle + 'deg';
            }
        }
    }
    _pointerEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.button != 2)
            this.designerCanvas.serviceContainer.designerTools.get(NamedTools.Pointer).pointerEventHandler(this.designerCanvas, event, this.extendedItem.element);
    }
    dispose() {
        this._removeAllOverlays();
    }
}
