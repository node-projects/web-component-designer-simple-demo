import { DesignItem } from '../../../item/DesignItem.js';
import { NodeType } from "../../../item/NodeType.js";
import { ExtensionType } from './ExtensionType.js';
export class ExtensionManager {
    designerCanvas;
    designItemsWithExtentions = new Set();
    constructor(designerCanvas) {
        this.designerCanvas = designerCanvas;
        designerCanvas.instanceServiceContainer.selectionService.onSelectionChanged.on(this._selectedElementsChanged.bind(this));
        designerCanvas.instanceServiceContainer.contentService.onContentChanged.on(this._contentChanged.bind(this));
    }
    _contentChanged(contentChanged) {
        requestAnimationFrame(() => {
            switch (contentChanged.changeType) {
                case 'added':
                    this.applyExtensions(contentChanged.designItems, ExtensionType.Permanent, null, true);
                    break;
                case 'moved':
                    this.refreshExtensions(contentChanged.designItems, ExtensionType.Permanent);
                    break;
                case 'parsed':
                    this.applyExtensions(Array.from(this.designerCanvas.rootDesignItem.children()), ExtensionType.Permanent, null, true);
                    break;
                case 'removed':
                    this.removeExtensions(contentChanged.designItems, true, ExtensionType.Permanent);
                    break;
            }
        });
    }
    _selectedElementsChanged(selectionChangedEvent) {
        if (selectionChangedEvent.oldSelectedElements && selectionChangedEvent.oldSelectedElements.length) {
            if (selectionChangedEvent.oldSelectedElements[0].parent) {
                const primaryContainer = DesignItem.GetOrCreateDesignItem(selectionChangedEvent.oldSelectedElements[0].parent.element, this.designerCanvas.serviceContainer, this.designerCanvas.instanceServiceContainer);
                this.removeExtension(primaryContainer, ExtensionType.PrimarySelectionContainer);
                this.removeExtension(selectionChangedEvent.oldSelectedElements[0], ExtensionType.PrimarySelection);
                this.removeExtensions(selectionChangedEvent.oldSelectedElements, false, ExtensionType.Selection);
            }
        }
        if (selectionChangedEvent.selectedElements && selectionChangedEvent.selectedElements.length) {
            this.applyExtensions(selectionChangedEvent.selectedElements, ExtensionType.Selection);
            this.applyExtension(selectionChangedEvent.selectedElements[0], ExtensionType.PrimarySelection);
            const primaryContainer = DesignItem.GetOrCreateDesignItem(selectionChangedEvent.selectedElements[0].parent.element, this.designerCanvas.serviceContainer, this.designerCanvas.instanceServiceContainer);
            this.applyExtension(primaryContainer, ExtensionType.PrimarySelectionContainer);
        }
        //this.refreshExtensions(selectionChangedEvent.selectedElements);
    }
    applyExtension(designItem, extensionType, event, recursive = false) {
        if (designItem && designItem.nodeType == NodeType.Element) {
            const extProv = this.designerCanvas.serviceContainer.designerExtensions.get(extensionType);
            let extensions = [];
            if (extProv) {
                for (let e of extProv) {
                    let shouldAppE = designItem.shouldAppliedDesignerExtensions.get(extensionType);
                    if (!shouldAppE)
                        shouldAppE = [];
                    shouldAppE.push(e);
                    designItem.shouldAppliedDesignerExtensions.set(extensionType, shouldAppE);
                    if (e.shouldExtend(this, this.designerCanvas, designItem)) {
                        let appE = designItem.appliedDesignerExtensions.get(extensionType);
                        if (!appE)
                            appE = [];
                        const ext = e.getExtension(this, this.designerCanvas, designItem);
                        try {
                            ext.extend(event);
                            extensions.push(ext);
                        }
                        catch (err) {
                            console.error(err);
                        }
                        appE.push(ext);
                        designItem.appliedDesignerExtensions.set(extensionType, appE);
                        this.designItemsWithExtentions.add(designItem);
                    }
                }
            }
            if (recursive) {
                for (const d of designItem.children()) {
                    this.applyExtension(d, extensionType, event, recursive);
                }
            }
            return extensions;
        }
        return null;
    }
    applyExtensions(designItems, extensionType, event, recursive = false) {
        if (designItems) {
            const extProv = this.designerCanvas.serviceContainer.designerExtensions.get(extensionType);
            if (extProv) {
                for (let e of extProv) {
                    for (let i of designItems) {
                        let shouldAppE = i.shouldAppliedDesignerExtensions.get(extensionType);
                        if (!shouldAppE)
                            shouldAppE = [];
                        shouldAppE.push(e);
                        i.shouldAppliedDesignerExtensions.set(extensionType, shouldAppE);
                        if (e.shouldExtend(this, this.designerCanvas, i)) {
                            let appE = i.appliedDesignerExtensions.get(extensionType);
                            if (!appE)
                                appE = [];
                            const ext = e.getExtension(this, this.designerCanvas, i);
                            try {
                                ext.extend(event);
                            }
                            catch (err) {
                                console.error(err);
                            }
                            appE.push(ext);
                            i.appliedDesignerExtensions.set(extensionType, appE);
                            this.designItemsWithExtentions.add(i);
                        }
                    }
                }
            }
            if (recursive) {
                for (const d of designItems) {
                    this.applyExtensions(Array.from(d.children()), extensionType, event, recursive);
                }
            }
        }
    }
    removeExtension(designItem, extensionType) {
        if (designItem) {
            if (extensionType) {
                designItem.shouldAppliedDesignerExtensions.delete(extensionType);
                let exts = designItem.appliedDesignerExtensions.get(extensionType);
                if (exts) {
                    for (let e of exts) {
                        try {
                            e.dispose();
                        }
                        catch (err) {
                            console.error(err);
                        }
                    }
                    designItem.appliedDesignerExtensions.delete(extensionType);
                    if (!designItem.appliedDesignerExtensions.size)
                        this.designItemsWithExtentions.delete(designItem);
                }
            }
            else {
                designItem.shouldAppliedDesignerExtensions.clear();
                for (let appE of designItem.appliedDesignerExtensions) {
                    for (let e of appE[1]) {
                        try {
                            e.dispose();
                        }
                        catch (err) {
                            console.error(err);
                        }
                    }
                }
                designItem.appliedDesignerExtensions.clear();
                this.designItemsWithExtentions.delete(designItem);
            }
        }
    }
    removeExtensions(designItems, recursive, extensionType) {
        if (designItems) {
            if (extensionType) {
                for (let i of designItems) {
                    if (recursive && i.hasChildren) {
                        this.removeExtensions([...i.children()], true, extensionType);
                    }
                    i.shouldAppliedDesignerExtensions.delete(extensionType);
                    let exts = i.appliedDesignerExtensions.get(extensionType);
                    if (exts) {
                        for (let e of exts) {
                            try {
                                e.dispose();
                            }
                            catch (err) {
                                console.error(err);
                            }
                        }
                        i.appliedDesignerExtensions.delete(extensionType);
                        if (!i.appliedDesignerExtensions.size)
                            this.designItemsWithExtentions.delete(i);
                    }
                }
            }
            else {
                for (let i of designItems) {
                    if (recursive && i.hasChildren) {
                        this.removeExtensions([...i.children()], true, extensionType);
                    }
                    i.shouldAppliedDesignerExtensions.clear();
                    for (let appE of i.appliedDesignerExtensions) {
                        for (let e of appE[1]) {
                            try {
                                e.dispose();
                            }
                            catch (err) {
                                console.error(err);
                            }
                        }
                    }
                    i.appliedDesignerExtensions.clear();
                    this.designItemsWithExtentions.delete(i);
                }
            }
        }
    }
    refreshExtension(designItem, extensionType, event) {
        if (designItem) {
            if (extensionType) {
                let exts = designItem.appliedDesignerExtensions.get(extensionType);
                if (exts) {
                    for (let e of exts) {
                        try {
                            e.refresh(event);
                        }
                        catch (err) {
                            console.error(err);
                        }
                    }
                }
            }
            else {
                for (let appE of designItem.appliedDesignerExtensions) {
                    for (let e of appE[1]) {
                        try {
                            e.refresh(event);
                        }
                        catch (err) {
                            console.error(err);
                        }
                    }
                }
            }
        }
    }
    refreshExtensions(designItems, extensionType, event, ignoredExtension) {
        if (designItems) {
            if (extensionType) {
                for (let i of designItems) {
                    let exts = i.appliedDesignerExtensions.get(extensionType);
                    if (exts) {
                        for (let e of exts) {
                            try {
                                if (e != ignoredExtension)
                                    e.refresh(event);
                            }
                            catch (err) {
                                console.error(err);
                            }
                        }
                    }
                }
            }
            else {
                for (let i of designItems) {
                    for (let appE of i.appliedDesignerExtensions) {
                        for (let e of appE[1]) {
                            try {
                                if (e != ignoredExtension)
                                    e.refresh(event);
                            }
                            catch (err) {
                                console.error(err);
                            }
                        }
                    }
                }
            }
        }
    }
    refreshAllExtensions(designItems, ignoredExtension) {
        if (designItems) {
            this.refreshExtensions(designItems, ExtensionType.Permanent, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.Selection, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.PrimarySelection, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.PrimarySelectionContainer, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.MouseOver, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.OnlyOneItemSelected, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.MultipleItemsSelected, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.ContainerDragOver, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.ContainerDrag, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.Doubleclick, null, ignoredExtension);
            this.refreshExtensions(designItems, ExtensionType.Placement, null, ignoredExtension);
        }
    }
    refreshAllAppliedExtentions() {
        this.refreshAllExtensions([...this.designItemsWithExtentions]);
    }
    //todo does not work with permanant, when not applied... maybe we need to do in another way
    //maybe store the "shouldAppliedExtensions??"
    reapplyAllAppliedExtentions() {
        for (let d of ExtensionManager.getAllChildElements(this.designerCanvas.rootDesignItem)) {
            const keys = [...d.shouldAppliedDesignerExtensions.keys()];
            for (let e of keys) {
                this.removeExtension(d, e);
                this.applyExtension(d, e);
            }
        }
    }
    static *getAllChildElements(designItem) {
        if (designItem.nodeType == NodeType.Element)
            yield designItem;
        if (designItem.hasChildren) {
            for (let c of designItem.children())
                for (let di of ExtensionManager.getAllChildElements(c))
                    yield di;
        }
    }
}
