import { EventNames } from "../../../../../enums/EventNames.js";
import { CalculateGridInformation } from "../../../../helper/GridHelper.js";
import { AbstractExtension } from '../AbstractExtension.js';
import { OverlayLayer } from "../OverlayLayer.js";
export class EditGridColumnRowSizesExtension extends AbstractExtension {
    gridInformation;
    _resizers = [];
    _initalPos;
    _initialSizes;
    constructor(extensionManager, designerView, extendedItem) {
        super(extensionManager, designerView, extendedItem);
    }
    extend(event) {
        this.refresh(event);
    }
    refresh(event) {
        this.gridInformation = CalculateGridInformation(this.extendedItem);
        this.gridInformation.gaps.forEach((gap, i) => {
            if (gap.width < 3) {
                gap.width = 3;
                gap.x--;
            }
            if (gap.height < 3) {
                gap.height = 3;
                gap.y--;
            }
            let rect = this._drawRect(gap.x, gap.y, gap.width, gap.height, 'svg-grid-resizer-' + gap.type, this._resizers[i], OverlayLayer.Normal);
            if (!this._resizers[i]) {
                rect.addEventListener(EventNames.PointerDown, event => this._pointerActionTypeResize(event, rect, gap, i));
                rect.addEventListener(EventNames.PointerMove, event => this._pointerActionTypeResize(event, rect, gap, i));
                rect.addEventListener(EventNames.PointerUp, event => this._pointerActionTypeResize(event, rect, gap, i));
            }
        });
    }
    _pointerActionTypeResize(event, rect, gap, index) {
        event.stopPropagation();
        const templatePropertyName = gap.type == 'h' ? 'gridTemplateRows' : 'gridTemplateColumns';
        const axisPropertyName = gap.type == 'h' ? 'Y' : 'X';
        const pos = event['client' + axisPropertyName];
        switch (event.type) {
            case EventNames.PointerDown:
                rect.setPointerCapture(event.pointerId);
                this._initalPos = pos;
                this._initialSizes = getComputedStyle(this.extendedItem.element)[templatePropertyName];
                break;
            case EventNames.PointerMove:
                if (this._initialSizes) {
                    const diff = this._initalPos - pos;
                    let parts = this._initialSizes.split(' ');
                    parts[index] = (parseFloat(parts[index]) - diff) + 'px';
                    parts[index + 1] = (parseFloat(parts[index + 1]) + diff) + 'px';
                    this.extendedItem.element.style[templatePropertyName] = parts.join(' ');
                    this.refresh();
                }
                break;
            case EventNames.PointerUp:
                rect.releasePointerCapture(event.pointerId);
                //if (circle.style.cursor == "ew-resize")
                //  this.extendedItem.setStyle("grid-template-columns", this._calculateNewSize(this._initialSizes.x, this._initialSizes.xUnit, (event.clientX - this._initialPoint.x) / this.designerCanvas.zoomFactor, gapColumn, "width", true));
                //else if (circle.style.cursor == "ns-resize")
                //  this.extendedItem.setStyle("grid-template-rows", this._calculateNewSize(this._initialSizes.y, this._initialSizes.yUnit, (event.clientY - this._initialPoint.y) / this.designerCanvas.zoomFactor, gapRow, "height", true));
                this._initalPos = null;
                this._initialSizes = null;
                this.refresh();
                break;
        }
    }
    dispose() {
        this._removeAllOverlays();
    }
}
