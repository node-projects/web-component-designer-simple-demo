import { EventNames } from '../../../../enums/EventNames.js';
import { OverlayLayer } from '../extensions/OverlayLayer.js';
import { calculateNormLegth } from '../../../helper/PathDataPolyfill.js';
import { DesignItem } from '../../../item/DesignItem.js';
import { InsertAction } from '../../../services/undoService/transactionItems/InsertAction.js';
export class DrawRectTool {
    cursor = 'crosshair';
    _path;
    _startPoint;
    _minX;
    _minY;
    _maxX;
    _maxY;
    _px;
    _py;
    constructor() {
    }
    activated(serviceContainer) {
    }
    dispose() {
    }
    pointerEventHandler(designerCanvas, event, currentElement) {
        const currentPoint = designerCanvas.getNormalizedEventCoordinates(event);
        const offset = 10;
        switch (event.type) {
            case EventNames.PointerDown:
                this._startPoint = currentPoint;
                event.target.setPointerCapture(event.pointerId);
                designerCanvas.captureActiveTool(this);
                this._path = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                this._path.setAttribute("stroke", designerCanvas.serviceContainer.globalContext.strokeColor);
                this._path.setAttribute("fill", designerCanvas.serviceContainer.globalContext.fillBrush);
                this._path.setAttribute("stroke-width", designerCanvas.serviceContainer.globalContext.strokeThickness);
                this._path.setAttribute("x", currentPoint.x.toString());
                this._path.setAttribute("y", currentPoint.y.toString());
                this._path.setAttribute("width", "0");
                this._path.setAttribute("height", "0");
                designerCanvas.overlayLayer.addOverlay(this.constructor.name, this._path, OverlayLayer.Foregorund);
                break;
            case EventNames.PointerMove:
                if (this._path) {
                    this._minX = currentPoint.x < this._startPoint.x ? currentPoint.x : this._startPoint.x;
                    this._maxX = currentPoint.x > this._startPoint.x ? currentPoint.x : this._startPoint.x;
                    this._minY = currentPoint.y < this._startPoint.y ? currentPoint.y : this._startPoint.y;
                    this._maxY = currentPoint.y > this._startPoint.y ? currentPoint.y : this._startPoint.y;
                    if (event.ctrlKey) {
                        if (event.shiftKey) {
                            const normLength = 2 * calculateNormLegth(this._startPoint, currentPoint);
                            this._px = this._startPoint.x - normLength / 2;
                            this._py = this._startPoint.y - normLength / 2;
                            this._path.setAttribute("width", (normLength).toString());
                            this._path.setAttribute("height", (normLength).toString());
                        }
                        else {
                            const w = 2 * (this._maxX - this._minX);
                            const h = 2 * (this._maxY - this._minY);
                            this._px = currentPoint.x < this._startPoint.x ? currentPoint.x : this._startPoint.x - w / 2;
                            this._py = currentPoint.y < this._startPoint.y ? currentPoint.y : this._startPoint.y - h / 2;
                            this._path.setAttribute("width", (w).toString());
                            this._path.setAttribute("height", (h).toString());
                        }
                        this._path.setAttribute("x", this._px.toString());
                        this._path.setAttribute("y", this._py.toString());
                    }
                    else {
                        if (event.shiftKey) {
                            const normLength = calculateNormLegth(this._startPoint, currentPoint);
                            this._px = currentPoint.x < this._startPoint.x ? this._startPoint.x - normLength : this._startPoint.x;
                            this._py = currentPoint.y < this._startPoint.y ? this._startPoint.y - normLength : this._startPoint.y;
                            this._path.setAttribute("width", (normLength).toString());
                            this._path.setAttribute("height", (normLength).toString());
                        }
                        else {
                            this._px = currentPoint.x < this._startPoint.x ? currentPoint.x : this._startPoint.x;
                            this._py = currentPoint.y < this._startPoint.y ? currentPoint.y : this._startPoint.y;
                            this._path.setAttribute("width", (this._maxX - this._minX).toString());
                            this._path.setAttribute("height", (this._maxY - this._minY).toString());
                        }
                        this._path.setAttribute("x", this._px.toString());
                        this._path.setAttribute("y", this._py.toString());
                    }
                }
                break;
            case EventNames.PointerUp:
                event.target.releasePointerCapture(event.pointerId);
                designerCanvas.releaseActiveTool();
                let coords = designerCanvas.getNormalizedElementCoordinates(this._path);
                designerCanvas.overlayLayer.removeOverlay(this._path);
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                const mvX = coords.x - offset;
                const mvY = coords.y - offset;
                this._path.setAttribute("x", (this._px - mvX).toString());
                this._path.setAttribute("y", (this._py - mvY).toString());
                svg.appendChild(this._path);
                svg.style.left = (mvX) + 'px';
                svg.style.top = (mvY) + 'px';
                svg.style.position = 'absolute';
                svg.style.width = Math.round(coords.width + 2 * offset) + 'px';
                svg.style.height = Math.round(coords.height + 2 * offset) + 'px';
                svg.style.overflow = 'visible';
                this._path = null;
                const di = DesignItem.createDesignItemFromInstance(svg, designerCanvas.serviceContainer, designerCanvas.instanceServiceContainer);
                designerCanvas.instanceServiceContainer.undoService.execute(new InsertAction(designerCanvas.rootDesignItem, designerCanvas.rootDesignItem.childCount, di));
                designerCanvas.serviceContainer.globalContext.finishedWithTool(this);
                break;
        }
    }
    keyboardEventHandler(designerCanvas, event, currentElement) { }
}
