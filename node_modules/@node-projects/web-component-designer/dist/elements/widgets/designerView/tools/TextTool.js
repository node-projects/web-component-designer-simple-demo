import { EventNames } from '../../../../enums/EventNames.js';
import { DesignItem } from '../../../item/DesignItem.js';
import { InsertAction } from '../../../services/undoService/transactionItems/InsertAction.js';
import { ExtensionType } from '../extensions/ExtensionType.js';
export class TextTool {
    _textEditExtensions;
    constructor(editExistingText) {
        if (editExistingText)
            this._editExistingText = true;
    }
    activated(serviceContainer) {
        this._textCreated = false;
    }
    dispose() {
    }
    cursor = 'text';
    _textCreated = false;
    _editExistingText = false;
    pointerEventHandler(designerCanvas, event, currentElement) {
        const currentPoint = designerCanvas.getNormalizedEventCoordinates(event);
        switch (event.type) {
            case EventNames.PointerDown:
                if (!this._textCreated && !this._editExistingText) {
                    this._textCreated = true;
                    const span = document.createElement('span');
                    const di = DesignItem.createDesignItemFromInstance(span, designerCanvas.serviceContainer, designerCanvas.instanceServiceContainer);
                    di.setStyle('position', 'absolute');
                    di.setStyle('left', currentPoint.x + 'px');
                    di.setStyle('top', currentPoint.y + 'px');
                    designerCanvas.instanceServiceContainer.undoService.execute(new InsertAction(designerCanvas.rootDesignItem, designerCanvas.rootDesignItem.childCount, di));
                    //todo: Maybe we could also remove the eatEvents property
                    //TODO - don't apply doubleclick extension (maybe it is not the doubleclick one) - apply edit text extesion directly
                    //should we configure the editTextExtension anywhere??
                    this._textEditExtensions = designerCanvas.extensionManager.applyExtension(di, ExtensionType.Doubleclick, event);
                    setTimeout(() => { span.focus(); }, 50);
                }
                else {
                    for (let e of this._textEditExtensions) {
                        if (e.handlesPointerEvent) {
                            const ret = e.handlesPointerEvent(designerCanvas, event, currentElement);
                            if (!ret) {
                                designerCanvas.serviceContainer.globalContext.finishedWithTool(this);
                            }
                        }
                    }
                }
                break;
        }
    }
    keyboardEventHandler(designerCanvas, event, currentElement) { }
}
