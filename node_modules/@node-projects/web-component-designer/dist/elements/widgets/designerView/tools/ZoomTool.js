import { EventNames } from '../../../../enums/EventNames.js';
import { OverlayLayer } from '../extensions/OverlayLayer.js';
export class ZoomTool {
    cursor = 'zoom-in';
    _rect;
    _startPoint;
    _endPoint;
    _pointerMovementTolerance = 5;
    _zoomStepSize = 0.2; //number x 100 = Scale in percent
    activated(serviceContainer) {
    }
    pointerEventHandler(designerCanvas, event, currentElement) {
        const eventPoint = designerCanvas.getNormalizedEventCoordinates(event);
        switch (event.type) {
            case EventNames.PointerDown:
                this._startPoint = eventPoint;
                if (!this._rect)
                    this._rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                this._rect.setAttribute('class', 'svg-selector');
                this._rect.setAttribute('x', (this._startPoint.x * designerCanvas.zoomFactor));
                this._rect.setAttribute('y', (this._startPoint.y * designerCanvas.zoomFactor));
                this._rect.setAttribute('width', 0);
                this._rect.setAttribute('height', 0);
                this._rect.style.strokeWidth = '' + (1 / designerCanvas.scaleFactor);
                this._rect.style.strokeDasharray = '' + (2 / designerCanvas.scaleFactor);
                designerCanvas.overlayLayer.addOverlay(this.constructor.name, this._rect, OverlayLayer.Foregorund);
                break;
            case EventNames.PointerMove:
                if (this._startPoint) {
                    let width = eventPoint.x - this._startPoint.x;
                    let height = eventPoint.y - this._startPoint.y;
                    if (width >= 0) {
                        this._rect.setAttribute('x', this._startPoint.x);
                        this._rect.setAttribute('width', width);
                    }
                    else {
                        this._rect.setAttribute('x', eventPoint.x);
                        this._rect.setAttribute('width', (-1 * width));
                    }
                    if (height >= 0) {
                        this._rect.setAttribute('y', this._startPoint.y);
                        this._rect.setAttribute('height', height);
                    }
                    else {
                        this._rect.setAttribute('y', eventPoint.y);
                        this._rect.setAttribute('height', (-1 * height));
                    }
                }
                break;
            case EventNames.PointerUp:
                this._endPoint = eventPoint;
                let isLeftClick = event.button == 0;
                switch (event.button) {
                    case 0: //Left-Click
                    case 2: //Right-Click
                        this._zoomOnto(isLeftClick, this._startPoint, this._endPoint, designerCanvas);
                        break;
                }
                designerCanvas.overlayLayer.removeOverlay(this._rect);
                this._rect = null;
                this._startPoint = null;
                break;
        }
    }
    _zoomOnto(isZoomInto, startPoint, endPoint, designerCanvas) {
        if (this._isPositionEqual(startPoint, endPoint)) {
            const oldZoom = designerCanvas.zoomFactor;
            const newZoom = isZoomInto ? oldZoom + this._zoomStepSize : oldZoom - this._zoomStepSize;
            designerCanvas.zoomTowardsPoint(endPoint, newZoom);
        }
        else {
            designerCanvas.zoomOntoRectangle(startPoint, endPoint);
        }
    }
    _isPositionEqual(startPoint, endPoint) {
        let tolerance = this._pointerMovementTolerance;
        return Math.abs(startPoint.x - endPoint.x) <= tolerance && Math.abs(startPoint.y - endPoint.y) <= tolerance;
    }
    keyboardEventHandler(designerCanvas, event, currentElement) { }
    dispose() {
    }
}
