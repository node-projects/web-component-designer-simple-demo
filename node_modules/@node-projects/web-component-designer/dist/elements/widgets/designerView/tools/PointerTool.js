import { EventNames } from "../../../../enums/EventNames.js";
import { PointerActionType } from "../../../../enums/PointerActionType.js";
import { DesignItem } from "../../../item/DesignItem.js";
import { ExtensionType } from "../extensions/ExtensionType.js";
import { NamedTools } from "./NamedTools.js";
export class PointerTool {
  constructor() {
    this.cursor = 'default';
    this._movedSinceStartedAction = false;
    this._clickThroughElements = [];
  }

  dispose() {}

  pointerEventHandler(designerView, event, currentElement) {
    switch (event.type) {
      case EventNames.PointerDown:
        event.target.setPointerCapture(event.pointerId);
        this._movedSinceStartedAction = false;
        break;

      case EventNames.PointerUp:
        event.target.releasePointerCapture(event.pointerId);
        break;
    }

    if (!event.altKey) this._resetPointerEventsForClickThrough();
    if (!currentElement) return;
    const currentPoint = designerView.getDesignerMousepoint(event, currentElement, event.type === 'pointerdown' ? null : this._initialPoint);
    const currentDesignItem = DesignItem.GetOrCreateDesignItem(currentElement, designerView.serviceContainer, designerView.instanceServiceContainer);

    if (this._actionType == null) {
      this._initialPoint = currentPoint;

      if (event.type == EventNames.PointerDown) {
        this._actionStartedDesignItem = currentDesignItem;
        designerView.snapLines.clearSnaplines();

        if (currentDesignItem !== designerView.rootDesignItem) {
          this._actionType = PointerActionType.Drag;
        } else if (currentElement === designerView || currentElement === designerView.rootDesignItem.element || currentElement == null) {
          designerView.instanceServiceContainer.selectionService.setSelectedElements(null);
          this._actionType = PointerActionType.DrawSelection;
        } else {
          this._actionType = PointerActionType.DragOrSelect;
        }
      }
    }

    if (event.type === EventNames.PointerMove) {
      this._movedSinceStartedAction = this._movedSinceStartedAction || currentPoint.x != this._initialPoint.x || currentPoint.y != this._initialPoint.y;
      if (this._actionType == PointerActionType.DrawSelection) this._actionType = PointerActionType.DrawingSelection;
    }

    if (this._actionType == PointerActionType.DrawSelection || this._actionType == PointerActionType.DrawingSelection) {
      this._pointerActionTypeDrawSelection(designerView, event, currentElement);
    } else if (this._actionType == PointerActionType.DragOrSelect || this._actionType == PointerActionType.Drag) {
      this._pointerActionTypeDragOrSelect(designerView, event, currentDesignItem, currentPoint);
    }

    if (event.type == EventNames.PointerUp) {
      designerView.snapLines.clearSnaplines();

      if (this._actionType == PointerActionType.DrawSelection) {
        if (currentDesignItem !== designerView.rootDesignItem) designerView.instanceServiceContainer.selectionService.setSelectedElements([currentDesignItem]);
      }

      this._actionType = null;
      this._actionStartedDesignItem = null;
      this._movedSinceStartedAction = false;
      this._initialPoint = null;
    }

    this._previousEventName = event.type;
  }

  _pointerActionTypeDrawSelection(designerView, event, currentElement) {
    const drawSelectionTool = designerView.serviceContainer.designerTools.get(NamedTools.DrawSelection);

    if (drawSelectionTool) {
      drawSelectionTool.pointerEventHandler(designerView, event, currentElement);
    }
  }

  _resetPointerEventsForClickThrough() {
    if (!this._clickThroughElements.length) return;

    for (const e of this._clickThroughElements) {
      e[0].element.style.pointerEvents = e[1];
    }

    this._clickThroughElements = [];
  }

  _pointerActionTypeDragOrSelect(designerView, event, currentDesignItem, currentPoint) {
    if (event.altKey) {
      if (event.type == EventNames.PointerDown) {
        this._clickThroughElements.push([currentDesignItem, currentDesignItem.element.style.pointerEvents]);

        currentDesignItem.element.style.pointerEvents = 'none';
      }

      let currentElement = designerView.elementFromPoint(event.x, event.y);
      if (currentElement.parentNode !== designerView.overlayLayer) currentDesignItem = DesignItem.GetOrCreateDesignItem(currentElement, designerView.serviceContainer, designerView.instanceServiceContainer);
    } else {
      this._resetPointerEventsForClickThrough();
    }

    switch (event.type) {
      case EventNames.PointerDown:
        {
          this._actionStartedDesignItem = currentDesignItem;

          if (event.shiftKey || event.ctrlKey) {
            const index = designerView.instanceServiceContainer.selectionService.selectedElements.indexOf(currentDesignItem);

            if (index >= 0) {
              let newSelectedList = designerView.instanceServiceContainer.selectionService.selectedElements.slice(0);
              newSelectedList.splice(index, 1);
              designerView.instanceServiceContainer.selectionService.setSelectedElements(newSelectedList);
            } else {
              let newSelectedList = designerView.instanceServiceContainer.selectionService.selectedElements.slice(0);
              newSelectedList.push(currentDesignItem);
              designerView.instanceServiceContainer.selectionService.setSelectedElements(newSelectedList);
            }
          } else {
            if (designerView.instanceServiceContainer.selectionService.selectedElements.indexOf(currentDesignItem) < 0) designerView.instanceServiceContainer.selectionService.setSelectedElements([currentDesignItem]);
          }

          if (designerView.alignOnSnap) designerView.snapLines.calculateSnaplines(designerView.instanceServiceContainer.selectionService.selectedElements);
          break;
        }

      case EventNames.PointerMove:
        {
          const elementMoved = currentPoint.x != this._initialPoint.x || currentPoint.y != this._initialPoint.y;

          if (this._actionType != PointerActionType.Drag && elementMoved) {
            this._actionType = PointerActionType.Drag;
          }

          if (this._movedSinceStartedAction) {
            const currentContainerService = designerView.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(this._actionStartedDesignItem.parent));

            if (currentContainerService && currentContainerService.canLeave(this._actionStartedDesignItem.parent, [this._actionStartedDesignItem])) {
              const dragItem = this._actionStartedDesignItem.parent;

              if (this._dragExtensionItem != dragItem) {
                designerView.extensionManager.removeExtension(this._dragExtensionItem, ExtensionType.ContainerDrag);
                designerView.extensionManager.applyExtension(dragItem, ExtensionType.ContainerDrag);
                this._dragExtensionItem = dragItem;
              } else {
                designerView.extensionManager.refreshExtension(dragItem, ExtensionType.ContainerDrag);
              } //search for containers below mouse cursor.
              //to do this, we need to disable pointer events for each in a loop and search wich element is there


              let backupPEventsMap = new Map();
              let newContainerElement = designerView.elementFromPoint(event.x, event.y);

              try {
                checkAgain: while (newContainerElement != null) {
                  if (newContainerElement == this._actionStartedDesignItem.parent.element) {
                    newContainerElement = null;
                  } else if (newContainerElement == designerView.rootDesignItem.element) {
                    break;
                  } else if (newContainerElement == designerView.overlayLayer || newContainerElement.parentElement == designerView.overlayLayer) {
                    backupPEventsMap.set(newContainerElement, newContainerElement.style.pointerEvents);
                    newContainerElement.style.pointerEvents = 'none';
                    newContainerElement = designerView.elementFromPoint(event.x, event.y);
                  } else if (newContainerElement == this._actionStartedDesignItem.element) {
                    backupPEventsMap.set(newContainerElement, newContainerElement.style.pointerEvents);
                    newContainerElement.style.pointerEvents = 'none';
                    newContainerElement = designerView.elementFromPoint(event.x, event.y);
                  } else {
                    //check we don't try to move a item over one of its children...
                    let par = newContainerElement.parentElement;

                    while (par) {
                      if (par == this._actionStartedDesignItem.element) {
                        backupPEventsMap.set(newContainerElement, newContainerElement.style.pointerEvents);
                        newContainerElement.style.pointerEvents = 'none';
                        newContainerElement = designerView.elementFromPoint(event.x, event.y);
                        continue checkAgain;
                      }

                      par = par.parentElement;
                    } //end check


                    const newContainerElementDesignItem = DesignItem.GetOrCreateDesignItem(newContainerElement, designerView.serviceContainer, designerView.instanceServiceContainer);
                    const newContainerService = designerView.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(newContainerElementDesignItem));
                    if (newContainerService && newContainerService.canEnter(newContainerElementDesignItem, [this._actionStartedDesignItem])) break;
                    backupPEventsMap.set(newContainerElement, newContainerElement.style.pointerEvents);
                    newContainerElement.style.pointerEvents = 'none';
                    newContainerElement = designerView.elementFromPoint(event.x, event.y);
                  }
                }
              } finally {
                for (let e of backupPEventsMap.entries()) {
                  e[0].style.pointerEvents = e[1];
                }
              } //if we found a new enterable container create extensions 


              if (newContainerElement != null) {
                const newContainerElementDesignItem = DesignItem.GetOrCreateDesignItem(newContainerElement, designerView.serviceContainer, designerView.instanceServiceContainer);

                if (this._dragOverExtensionItem != newContainerElementDesignItem) {
                  designerView.extensionManager.removeExtension(this._dragOverExtensionItem, ExtensionType.ContainerDragOver);
                  designerView.extensionManager.applyExtension(newContainerElementDesignItem, ExtensionType.ContainerDragOver);
                  this._dragOverExtensionItem = newContainerElementDesignItem;
                } else {
                  designerView.extensionManager.refreshExtension(newContainerElementDesignItem, ExtensionType.ContainerDragOver);
                }
              } else {
                if (this._dragOverExtensionItem) {
                  designerView.extensionManager.removeExtension(this._dragOverExtensionItem, ExtensionType.ContainerDragOver);
                  this._dragOverExtensionItem = null;
                }
              }

              const containerService = designerView.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(this._actionStartedDesignItem.parent));
              containerService.place(event, designerView, this._actionStartedDesignItem.parent, this._initialPoint, currentPoint, designerView.instanceServiceContainer.selectionService.selectedElements);
              designerView.extensionManager.refreshExtensions(designerView.instanceServiceContainer.selectionService.selectedElements);
            }
          }

          break;
        }

      case EventNames.PointerUp:
        {
          if (this._actionType == PointerActionType.DragOrSelect) {
            if (this._previousEventName == EventNames.PointerDown && !event.shiftKey && !event.ctrlKey) designerView.instanceServiceContainer.selectionService.setSelectedElements([currentDesignItem]);
            return;
          }

          if (this._movedSinceStartedAction) {
            let containerService = designerView.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(this._actionStartedDesignItem.parent));

            if (containerService) {
              let cg = designerView.rootDesignItem.openGroup("Move Elements", designerView.instanceServiceContainer.selectionService.selectedElements);
              containerService.finishPlace(event, designerView, this._actionStartedDesignItem.parent, this._initialPoint, currentPoint, designerView.instanceServiceContainer.selectionService.selectedElements);
              cg.commit();
            }

            designerView.extensionManager.removeExtension(this._dragExtensionItem, ExtensionType.ContainerDrag);
            this._dragExtensionItem = null;
            designerView.extensionManager.removeExtension(this._dragOverExtensionItem, ExtensionType.ContainerDragOver);
            this._dragOverExtensionItem = null;
          }

          designerView.extensionManager.refreshExtensions(designerView.instanceServiceContainer.selectionService.selectedElements);
          break;
        }
    }
  }

}