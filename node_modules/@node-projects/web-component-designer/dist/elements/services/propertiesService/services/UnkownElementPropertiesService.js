import { ValueType } from "../ValueType.js";
import { PropertiesHelper } from "./PropertiesHelper.js";
export class UnkownElementPropertiesService {
  constructor() {
    this.name = "unkown";
  }

  isHandledElement(designItem) {
    return true;
  }

  _notifyChangedProperty(designItem, property, value) {}

  getProperty(designItem, name) {
    return null;
  }

  getProperties(designItem) {
    return null;
  }

  setValue(designItems, property, value) {
    const attributeName = PropertiesHelper.camelToDashCase(property.name);
    const cg = designItems[0].openGroup("properties changed", designItems);

    try {
      for (let d of designItems) {
        if (property.type === 'object') {
          const json = JSON.stringify(value);
          d.attributes.set(attributeName, json);
          d.element.setAttribute(attributeName, json);
        } else if (property.type == 'boolean' && !value) {
          d.attributes.delete(attributeName);
          d.element.removeAttribute(attributeName);
        } else if (property.type == 'boolean' && value) {
          d.attributes.set(attributeName, "");
          d.element.setAttribute(attributeName, "");
        } else {
          d.attributes.set(attributeName, value);
          d.element.setAttribute(attributeName, value);
        }

        this._notifyChangedProperty(d, property, value);
      }

      cg.commit();
    } catch (err) {
      console.log(err);
      cg.undo();
    }
  }

  clearValue(designItems, property) {
    const attributeName = PropertiesHelper.camelToDashCase(property.name);

    for (let d of designItems) {
      d.attributes.delete(attributeName);
      d.element.removeAttribute(attributeName);

      this._notifyChangedProperty(d, property, undefined);
    }
  }

  isSet(designItems, property) {
    let all = true;
    let some = false;

    if (designItems != null && designItems.length !== 0) {
      let attributeName = PropertiesHelper.camelToDashCase(property.name);
      designItems.forEach(x => {
        let has = x.attributes.has(attributeName);
        all = all && has;
        some = some || has;
      });
    } else return ValueType.none;

    return all ? ValueType.all : some ? ValueType.some : ValueType.none;
  }

  getValue(designItems, property) {
    if (designItems != null && designItems.length !== 0) {
      let attributeName = PropertiesHelper.camelToDashCase(property.name);
      if (property.type == 'boolean') return designItems[0].attributes.has(attributeName);
      let lastValue = designItems[0].attributes.get(attributeName);
      /*
      for (const x of designItems) {
        let value = x.attributes.get(attributeName);
        if (value != lastValue) {
          lastValue = null;
          break;
        }
      }
      */

      return lastValue;
    }

    return null;
  }

  getUnsetValue(designItems, property) {
    return property.defaultValue;
  }

}