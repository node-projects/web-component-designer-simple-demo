import { RefreshMode } from '../IPropertiesService.js';
import { ValueType } from '../ValueType.js';
import { BindingTarget } from '../../../item/BindingTarget.js';
import { PropertyType } from '../PropertyType.js';
import { PropertiesHelper } from './PropertiesHelper.js';
import { AbstractPropertiesService } from './AbstractPropertiesService.js';
export class AttributesPropertiesService extends AbstractPropertiesService {
    name = "attributes";
    getRefreshMode(designItem) {
        return RefreshMode.fullOnValueChange;
    }
    isHandledElement(designItem) {
        return !designItem.isRootItem;
    }
    getProperty(designItem, name) {
        return { name: name, type: 'string', service: this, propertyType: PropertyType.attribute };
    }
    getProperties(designItem) {
        if (designItem) {
            let p = [];
            for (let a of designItem.attributes()) {
                p.push({ name: a[0], renamable: true, type: 'string', service: this, propertyType: PropertyType.attribute });
            }
            p.push({ name: '', type: 'addNew', service: this, propertyType: PropertyType.complex });
            return p;
        }
        return null;
    }
    async setValue(designItems, property, value) {
        const cg = designItems[0].openGroup("properties changed");
        for (let d of designItems) {
            d.setAttribute(property.name, value);
        }
        cg.commit();
    }
    getPropertyTarget(designItem, property) {
        return BindingTarget.attribute;
    }
    clearValue(designItems, property) {
        for (let d of designItems) {
            d.removeAttribute(property.name);
            d.serviceContainer.forSomeServicesTillResult('bindingService', (s) => {
                return s.clearBinding(d, property.name, this.getPropertyTarget(d, property));
            });
        }
    }
    isSet(designItems, property) {
        let all = true;
        let some = false;
        if (designItems != null && designItems.length !== 0) {
            if (designItems.length == 1 && typeof designItems[0].getAttribute(property.name) == 'object')
                return ValueType.bound;
            let propName = PropertiesHelper.dashToCamelCase(property.name);
            let attributeName = property.name;
            designItems.forEach((x) => {
                let has = x.hasAttribute(attributeName);
                all = all && has;
                some = some || has;
            });
            const bindings = AbstractPropertiesService.getOrBuildCachedBindings(designItems[0]);
            if (bindings && bindings.find(x => x.target == BindingTarget.attribute && x.targetName == propName))
                return ValueType.bound;
        }
        else
            return ValueType.none;
        return all ? ValueType.all : some ? ValueType.some : ValueType.none;
    }
    getValue(designItems, property) {
        if (designItems != null && designItems.length !== 0) {
            let attributeName = property.name;
            let lastValue = designItems[0].getAttribute(attributeName);
            if (typeof lastValue === 'object')
                return lastValue.rawValue;
            /*
            for (const x of designItems) {
              let value = x.attributes.get(attributeName);
              if (value != lastValue) {
                lastValue = null;
                break;
              }
            }
            */
            return lastValue;
        }
        return null;
    }
    getBinding(designItems, property) {
        const bindings = AbstractPropertiesService.getOrBuildCachedBindings(designItems[0]);
        return bindings.find(x => (x.target == BindingTarget.property || x.target == BindingTarget.explicitProperty || x.target == BindingTarget.attribute) && x.targetName == property.name);
    }
    getUnsetValue(designItems, property) {
        return property.defaultValue;
    }
}
