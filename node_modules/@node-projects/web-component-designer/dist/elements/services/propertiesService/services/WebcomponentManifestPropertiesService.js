import { BindingTarget } from "../../../item/BindingTarget.js";
import { RefreshMode } from "../IPropertiesService.js";
import { PropertyType } from "../PropertyType.js";
import { AbstractPropertiesService } from "./AbstractPropertiesService.js";
export class WebcomponentManifestPropertiesService extends AbstractPropertiesService {
    getRefreshMode(designItem) {
        return RefreshMode.full;
    }
    _name;
    get name() { return this._name; }
    _propertiesList;
    constructor(name, manifest) {
        super();
        this._name = name;
        this._parseManifest(manifest);
    }
    _parseManifest(manifest) {
        this._propertiesList = {};
        let declarations = [];
        for (let m of manifest.modules) {
            if (m.declarations)
                declarations.push(...m.declarations);
        }
        for (let m of manifest.modules) {
            for (let e of m.exports) {
                if (e.kind == 'custom-element-definition') {
                    let properties = [];
                    let declaration = declarations.find(x => x.name == e.declaration.name);
                    if (declaration) {
                        if (declaration.members) {
                            for (let d of declaration.members) {
                                if (d.kind == 'field' && d.privacy !== 'private' && d.privacy !== 'protected') {
                                    let pType = PropertyType.property;
                                    if (declaration.attributes)
                                        pType = declaration.attributes.find(x => x.fieldName == d.name) != null ? PropertyType.propertyAndAttribute : PropertyType.property;
                                    const p = this.manifestClassPropertyTypeToEditorPropertyType(d.type?.text);
                                    properties.push({ name: d.name, service: this, propertyType: pType, type: p[0], values: p[1], description: d.description });
                                }
                            }
                            this._propertiesList[e.name] = properties;
                        }
                    }
                    else {
                        console.warn('declaration for ' + e.declaration.name + ' not found', manifest);
                    }
                }
            }
        }
    }
    manifestClassPropertyTypeToEditorPropertyType(type) {
        if (type) {
            if (type.toLowerCase() === 'boolean')
                return ['boolean'];
            if (type.toLowerCase() === 'number')
                return ['number'];
            if (type.toLowerCase() === 'string')
                return ['string'];
            if (type.startsWith("'") && type.includes("|")) {
                const values = type.split("|").map(x => x.trim()).map(x => x.substring(1, x.length - 1));
                return ['list', values];
            }
        }
        return [type];
    }
    isHandledElement(designItem) {
        return this._propertiesList[designItem.name] != null;
    }
    getProperties(designItem) {
        return this._propertiesList[designItem.name];
    }
    getProperty(designItem, name) {
        return this._propertiesList[designItem.name].find(x => x.name == name);
    }
    getPropertyTarget(designItem, property) {
        return this._propertiesList[designItem.name].find(x => x.name == property.name).propertyType == PropertyType.attribute ? BindingTarget.attribute : BindingTarget.property;
    }
}
