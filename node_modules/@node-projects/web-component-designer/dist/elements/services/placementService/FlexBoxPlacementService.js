import { DefaultPlacementService } from './DefaultPlacementService.js';
export class FlexBoxPlacementService {
    _basePlacementService;
    constructor(basePlacementService) {
        this._basePlacementService = basePlacementService ?? new DefaultPlacementService();
    }
    enterContainer(container, items, mode) {
        for (let i of items) {
            container.insertChild(i);
            i.removeStyle("position");
            i.removeStyle("left");
            i.removeStyle("top");
            i.removeStyle("right");
            i.removeStyle("transform");
        }
    }
    leaveContainer(container, items) {
        for (let i of items) {
            if (!i.lastContainerSize) {
                const rect = i.element.getBoundingClientRect();
                i.lastContainerSize = { width: rect.width, height: rect.height };
            }
        }
    }
    serviceForContainer(container, containerStyle, item) {
        if (containerStyle.display == 'flex' || containerStyle.display == 'inline-flex') {
            if (item != null && item.getComputedStyle()?.position == 'absolute')
                return false;
            return true;
        }
        return false;
    }
    isEnterableContainer(container) {
        return this._basePlacementService.isEnterableContainer(container);
    }
    canEnter(container, items) {
        return this._basePlacementService.canEnter(container, items);
    }
    canLeave(container, items) {
        return true;
    }
    getElementOffset(container, designItem) {
        return container.element.getBoundingClientRect();
    }
    placePoint(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items) {
        const defaultPlacementService = container.serviceContainer.getLastServiceWhere('containerService', x => x instanceof DefaultPlacementService);
        return defaultPlacementService.placePoint(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items);
    }
    startPlace(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items) {
    }
    place(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items) {
        const pos = designerCanvas.getNormalizedEventCoordinates(event);
        const style = getComputedStyle(container.element);
        const childrenWithPos = Array.from(container.children()).filter(x => !x.isEmptyTextNode).map(x => [x, designerCanvas.getNormalizedElementCoordinates(x.element)]);
        if (style.flexDirection == 'row' || style.flexDirection == 'row-reverse') {
            childrenWithPos.sort(x => x[1].x);
            let elBefore = null;
            for (let c of childrenWithPos) {
                if (c[1].x + c[1].width / 2 < pos.x) {
                    elBefore = c;
                    if (style.flexDirection == 'row-reverse')
                        break;
                }
            }
            let posBefore = childrenWithPos.indexOf(elBefore);
            let posDrag = childrenWithPos.indexOf(childrenWithPos.find(x => x[0] == items[0]));
            if (elBefore && elBefore[0] != items[0]) {
                if (style.flexDirection == 'row-reverse' && posBefore - 1 === posDrag)
                    return;
                if (style.flexDirection == 'row' && posBefore + 1 === posDrag)
                    return;
                const sel = [...container.instanceServiceContainer.selectionService.selectedElements];
                let cg = items[0].openGroup('move in flexbox');
                if (items[0].parent)
                    items[0].remove();
                if (style.flexDirection == 'row-reverse')
                    elBefore[0].insertAdjacentElement(items[0], 'beforebegin');
                else
                    elBefore[0].insertAdjacentElement(items[0], 'afterend');
                cg.commit();
                container.instanceServiceContainer.selectionService.setSelectedElements(sel);
            }
            else if (elBefore == null) {
                if (posDrag == 0)
                    return;
                const sel = [...container.instanceServiceContainer.selectionService.selectedElements];
                let cg = items[0].openGroup('move in flexbox');
                if (items[0].parent)
                    items[0].remove();
                if (style.flexDirection == 'row-reverse')
                    container.insertChild(items[0]);
                else
                    container.insertChild(items[0], 0);
                cg.commit();
                container.instanceServiceContainer.selectionService.setSelectedElements(sel);
            }
        }
        else if (style.flexDirection == 'column' || style.flexDirection == 'column-reverse') {
            childrenWithPos.sort(x => x[1].y);
            let elBefore = null;
            for (let c of childrenWithPos) {
                if (c[1].y + c[1].height / 2 < pos.y) {
                    elBefore = c;
                    if (style.flexDirection == 'column-reverse')
                        break;
                }
            }
            let posBefore = childrenWithPos.indexOf(elBefore);
            let posDrag = childrenWithPos.indexOf(childrenWithPos.find(x => x[0] == items[0]));
            if (elBefore && elBefore[0] != items[0]) {
                if (style.flexDirection == 'column-reverse' && posBefore - 1 === posDrag)
                    return;
                if (style.flexDirection == 'column' && posBefore + 1 === posDrag)
                    return;
                const sel = [...container.instanceServiceContainer.selectionService.selectedElements];
                let cg = items[0].openGroup('move in flexbox');
                if (items[0].parent)
                    items[0].remove();
                if (style.flexDirection == 'column-reverse')
                    elBefore[0].insertAdjacentElement(items[0], 'beforebegin');
                else
                    elBefore[0].insertAdjacentElement(items[0], 'afterend');
                cg.commit();
                container.instanceServiceContainer.selectionService.setSelectedElements(sel);
            }
            else if (elBefore == null) {
                if (posDrag == 0)
                    return;
                const sel = [...container.instanceServiceContainer.selectionService.selectedElements];
                let cg = items[0].openGroup('move in flexbox');
                if (items[0].parent)
                    items[0].remove();
                if (style.flexDirection == 'column-reverse')
                    container.insertChild(items[0]);
                else
                    container.insertChild(items[0], 0);
                cg.commit();
                container.instanceServiceContainer.selectionService.setSelectedElements(sel);
            }
        }
        designerCanvas.extensionManager.refreshAllExtensions([container]);
    }
    finishPlace(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items) {
    }
    moveElements(designItems, position, absolute) {
    }
}
