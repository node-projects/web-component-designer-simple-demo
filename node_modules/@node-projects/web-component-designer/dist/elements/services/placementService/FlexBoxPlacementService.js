import { DefaultPlacementService } from './DefaultPlacementService.js';
export class FlexBoxPlacementService {
    enterContainer(container, items) {
        for (let i of items) {
            i.removeStyle("position");
            i.removeStyle("left");
            i.removeStyle("top");
            i.removeStyle("right");
            i.removeStyle("transform");
        }
    }
    leaveContainer(container, items) {
        for (let i of items) {
            if (!i.lastContainerSize) {
                const rect = i.element.getBoundingClientRect();
                i.lastContainerSize = { width: rect.width, height: rect.height };
            }
        }
    }
    serviceForContainer(container, containerStyle) {
        if (containerStyle.display == 'flex' || containerStyle.display == 'inline-flex')
            return true;
        return false;
    }
    canEnter(container, items) {
        return true;
    }
    canEnterByDrop(container) {
        return true;
    }
    canLeave(container, items) {
        return true;
    }
    getElementOffset(container, designItem) {
        return container.element.getBoundingClientRect();
    }
    placePoint(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        const defaultPlacementService = container.serviceContainer.getLastServiceWhere('containerService', x => x instanceof DefaultPlacementService);
        return defaultPlacementService.placePoint(event, placementView, container, startPoint, offsetInControl, newPoint, items);
    }
    startPlace(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
    }
    place(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        const pos = placementView.getNormalizedEventCoordinates(event);
        const style = getComputedStyle(container.element);
        const childrenWithPos = Array.from(container.children()).filter(x => !x.isEmptyTextNode).map(x => [x, placementView.getNormalizedElementCoordinates(x.element)]);
        if (style.flexDirection == 'row') {
            childrenWithPos.sort(x => x[1].x);
            let elBefore = null;
            for (let c of childrenWithPos) {
                if (c[1].x + c[1].width / 2 < pos.x) {
                    elBefore = c;
                }
            }
            let posBefore = childrenWithPos.indexOf(elBefore);
            let posDrag = childrenWithPos.indexOf(childrenWithPos.find(x => x[0] == items[0]));
            if (elBefore && elBefore[0] != items[0]) {
                if (posBefore + 1 === posDrag)
                    return;
                const sel = [...container.instanceServiceContainer.selectionService.selectedElements];
                let cg = items[0].openGroup('move in flexbox');
                items[0].remove();
                elBefore[0].insertAdjacentElement(items[0], 'afterend');
                cg.commit();
                container.instanceServiceContainer.selectionService.setSelectedElements(sel);
            }
            else if (elBefore == null) {
                if (posDrag == 0)
                    return;
                const sel = [...container.instanceServiceContainer.selectionService.selectedElements];
                let cg = items[0].openGroup('move in flexbox');
                items[0].remove();
                container.insertChild(items[0], 0);
                cg.commit();
                container.instanceServiceContainer.selectionService.setSelectedElements(sel);
            }
        }
        else if (style.flexDirection == 'column') {
            childrenWithPos.sort(x => x[1].y);
            let elBefore = null;
            for (let c of childrenWithPos) {
                if (c[1].y + c[1].height / 2 < pos.y) {
                    elBefore = c;
                }
            }
            let posBefore = childrenWithPos.indexOf(elBefore);
            let posDrag = childrenWithPos.indexOf(childrenWithPos.find(x => x[0] == items[0]));
            if (elBefore && elBefore[0] != items[0]) {
                if (posBefore + 1 === posDrag)
                    return;
                const sel = [...container.instanceServiceContainer.selectionService.selectedElements];
                let cg = items[0].openGroup('move in flexbox');
                items[0].remove();
                elBefore[0].insertAdjacentElement(items[0], 'afterend');
                cg.commit();
                container.instanceServiceContainer.selectionService.setSelectedElements(sel);
            }
            else if (elBefore == null) {
                if (posDrag == 0)
                    return;
                const sel = [...container.instanceServiceContainer.selectionService.selectedElements];
                let cg = items[0].openGroup('move in flexbox');
                items[0].remove();
                container.insertChild(items[0], 0);
                cg.commit();
                container.instanceServiceContainer.selectionService.setSelectedElements(sel);
            }
        }
        placementView.extensionManager.refreshAllExtensions([container]);
    }
    finishPlace(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
    }
    moveElements(designItems, position, absolute) {
    }
}
