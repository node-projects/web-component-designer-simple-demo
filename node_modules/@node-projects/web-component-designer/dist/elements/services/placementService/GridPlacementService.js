import { calculateGridInformation, getElementGridInformation } from '../../helper/GridHelper.js';
import { pointInRect } from '../../helper/Helper.js';
import { DefaultPlacementService } from './DefaultPlacementService.js';
export class GridPlacementService {
    _basePlacementService;
    constructor(basePlacementService) {
        this._basePlacementService = basePlacementService ?? new DefaultPlacementService();
    }
    enterContainer(container, items, mode) {
        for (let i of items) {
            container.insertChild(i);
            i.removeStyle("position");
            i.removeStyle("left");
            i.removeStyle("top");
            i.removeStyle("right");
            i.removeStyle("width");
            i.removeStyle("height");
            i.removeStyle("transform");
        }
    }
    leaveContainer(container, items) {
        for (let i of items) {
            if (!i.lastContainerSize) {
                const rect = i.element.getBoundingClientRect();
                i.lastContainerSize = { width: rect.width, height: rect.height };
            }
        }
    }
    serviceForContainer(container, containerStyle, item) {
        if (containerStyle.display == 'grid' || containerStyle.display == 'inline-grid') {
            if (item != null && item.getComputedStyle()?.position == 'absolute')
                return false;
            return true;
        }
        return false;
    }
    isEnterableContainer(container) {
        return this._basePlacementService.isEnterableContainer(container);
    }
    canEnter(container, items) {
        return this._basePlacementService.canEnter(container, items);
    }
    canLeave(container, items) {
        return true;
    }
    getElementOffset(container, designItem) {
        return container.element.getBoundingClientRect();
    }
    placePoint(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items) {
        const defaultPlacementService = container.serviceContainer.getLastServiceWhere('containerService', x => x instanceof DefaultPlacementService);
        return defaultPlacementService.placePoint(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items);
    }
    startPlace(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items) {
    }
    place(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items) {
        const gridInformation = calculateGridInformation(container);
        const pos = designerCanvas.getNormalizedEventCoordinates(event);
        //pos.x -= offsetInControl.x;
        //pos.y -= offsetInControl.y;
        let row = 0;
        let column = 0;
        for (let cellRow of gridInformation.cells) {
            column = 0;
            for (let cell of cellRow) {
                if (pointInRect(pos, cell)) {
                    let info = getElementGridInformation(items[0].element);
                    if (cell.name) {
                        items[0].element.style.gridColumn = '';
                        items[0].element.style.gridRow = '';
                        items[0].element.style.gridArea = cell.name;
                    }
                    else {
                        items[0].element.style.gridArea = '';
                        if (info.colSpan <= 1) {
                            items[0].element.style.gridColumn = '' + (column + 1);
                            items[0].element.style.gridRow = '' + (row + 1);
                        }
                        else {
                            items[0].element.style.gridColumnStart = '' + (column + 1);
                            items[0].element.style.gridRowStart = '' + (row + 1);
                            items[0].element.style.gridColumnEnd = '' + (column + info.colSpan + 1);
                            items[0].element.style.gridRowEnd = '' + (row + info.rowSpan + 1);
                        }
                    }
                }
                column++;
            }
            row++;
        }
        designerCanvas.extensionManager.refreshAllExtensions([container]);
    }
    finishPlace(event, designerCanvas, container, startPoint, offsetInControl, newPoint, items) {
        const gridInformation = calculateGridInformation(container);
        const pos = designerCanvas.getNormalizedEventCoordinates(event);
        //pos.x -= offsetInControl.x;
        //pos.y -= offsetInControl.y;
        let row = 0;
        let column = 0;
        row = 0;
        for (let cellRow of gridInformation.cells) {
            column = 0;
            for (let cell of cellRow) {
                if (pointInRect(pos, cell)) {
                    let info = getElementGridInformation(items[0].element);
                    //Grid Area is shorthand for grid row/column, to make undo work correctly we need to set befor and after clear
                    if (cell.name) {
                        items[0].setStyle('grid-area', cell.name);
                        items[0].removeStyle('grid-row-start');
                        items[0].removeStyle('grid-row-end');
                        items[0].removeStyle('grid-column-start');
                        items[0].removeStyle('grid-column-end');
                        items[0].removeStyle('grid-column');
                        items[0].removeStyle('grid-row');
                        items[0].setStyle('grid-area', cell.name);
                    }
                    else {
                        if (info.colSpan <= 1) {
                            items[0].removeStyle('grid-area');
                            items[0].removeStyle('grid-row-start');
                            items[0].removeStyle('grid-row-end');
                            items[0].removeStyle('grid-column-start');
                            items[0].removeStyle('grid-column-end');
                            items[0].setStyle('grid-column', '' + (column + 1));
                            items[0].setStyle('grid-row', '' + (row + 1));
                        }
                        else {
                            items[0].removeStyle('grid-area');
                            items[0].removeStyle('grid-column');
                            items[0].removeStyle('grid-row');
                            items[0].setStyle('grid-column-start', '' + (column + 1));
                            items[0].setStyle('grid-row-start', '' + (row + 1));
                            items[0].setStyle('grid-column-end', '' + (column + info.colSpan + 1));
                            items[0].setStyle('grid-row-end', '' + (row + info.rowSpan + 1));
                        }
                    }
                }
                column++;
            }
            row++;
        }
        designerCanvas.extensionManager.refreshAllExtensions([container]);
    }
    moveElements(designItems, position, absolute) {
    }
}
