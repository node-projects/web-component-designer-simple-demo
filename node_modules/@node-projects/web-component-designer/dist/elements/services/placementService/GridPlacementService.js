import { CalculateGridInformation } from '../../helper/GridHelper.js';
import { pointInRect } from '../../helper/Helper.js';
export class GridPlacementService {
    enterContainer(container, items) {
        for (let i of items) {
            i.removeStyle("position");
            i.removeStyle("left");
            i.removeStyle("top");
            i.removeStyle("right");
            i.removeStyle("width");
            i.removeStyle("height");
            i.removeStyle("transform");
        }
    }
    leaveContainer(container, items) {
        for (let i of items) {
            if (!i.lastContainerSize) {
                const rect = i.element.getBoundingClientRect();
                i.lastContainerSize = { width: rect.width, height: rect.height };
            }
        }
    }
    serviceForContainer(container) {
        if (container.element.style.display == 'grid' || container.element.style.display == 'inline-grid')
            return true;
        return false;
    }
    canEnter(container, items) {
        return true;
    }
    canLeave(container, items) {
        return true;
    }
    getElementOffset(container, designItem) {
        return container.element.getBoundingClientRect();
    }
    placePoint(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        return null;
    }
    place(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        const gridInformation = CalculateGridInformation(container);
        const pos = placementView.getNormalizedEventCoordinates(event);
        const posElement = placementView.getNormalizedElementCoordinates(items[0].element);
        let row = 0;
        let column = 0;
        if (!pointInRect(pos, posElement)) {
            row = 0;
            for (let cellRow of gridInformation.cells) {
                column = 0;
                for (let cell of cellRow) {
                    if (pointInRect(pos, cell)) {
                        items[0].element.style.gridColumn = column + 1;
                        items[0].element.style.gridRow = row + 1;
                    }
                    column++;
                }
                row++;
            }
        }
    }
    finishPlace(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        const gridInformation = CalculateGridInformation(container);
        const pos = placementView.getNormalizedEventCoordinates(event);
        let row = 0;
        let column = 0;
        row = 0;
        for (let cellRow of gridInformation.cells) {
            column = 0;
            for (let cell of cellRow) {
                if (pointInRect(pos, cell)) {
                    items[0].setStyle('grid-column', column + 1);
                    items[0].setStyle('grid-row', row + 1);
                }
                column++;
            }
            row++;
        }
    }
}
