import { DomConverter } from '../../widgets/designerView/DomConverter.js';
import { combineTransforms } from '../../helper/TransformHelper.js';
import { filterChildPlaceItems, placeDesignItem } from '../../helper/LayoutHelper.js';
export class DefaultPlacementService {
    serviceForContainer(container) {
        if (container.element.style.display === 'grid' || container.element.style.display === 'inline-grid' ||
            container.element.style.display === 'flex' || container.element.style.display === 'inline-flex')
            return false;
        return true;
    }
    canEnter(container, items) {
        if (DomConverter.IsSelfClosingElement(container.element.localName))
            return false;
        if (container.element.shadowRoot && container.element.shadowRoot.querySelector('slot') == null)
            return false;
        return true;
    }
    canLeave(container, items) {
        return true;
    }
    getElementOffset(container, designItem) {
        return container.element.getBoundingClientRect();
    }
    calculateTrack(event, placementView, startPoint, offsetInControl, newPoint, item) {
        let trackX = newPoint.x - startPoint.x;
        let trackY = newPoint.y - startPoint.y;
        if (!event.ctrlKey) {
            if (placementView.alignOnGrid) {
                trackX = Math.round(trackX / placementView.gridSize) * placementView.gridSize;
                trackY = Math.round(trackY / placementView.gridSize) * placementView.gridSize;
            }
            else if (placementView.alignOnSnap) {
                let rect = item.element.getBoundingClientRect();
                let newPos = placementView.snapLines.snapToPosition({ x: newPoint.x - offsetInControl.x, y: newPoint.y - offsetInControl.y }, { width: rect.width, height: rect.height }, { x: trackX > 0 ? 1 : -1, y: trackY > 0 ? 1 : -1 });
                if (newPos.x !== null) {
                    trackX = newPos.x - Math.round(startPoint.x) + Math.round(offsetInControl.x);
                }
                else {
                    trackX = Math.round(trackX);
                }
                if (newPos.y !== null) {
                    trackY = newPos.y - Math.round(startPoint.y) + Math.round(offsetInControl.y);
                }
                else {
                    trackY = Math.round(trackY);
                }
            }
        }
        return { x: trackX, y: trackY };
    }
    placePoint(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        let trackX = newPoint.x;
        let trackY = newPoint.y;
        if (!event.ctrlKey) {
            if (placementView.alignOnGrid) {
                trackX = Math.round(trackX / placementView.gridSize) * placementView.gridSize;
                trackY = Math.round(trackY / placementView.gridSize) * placementView.gridSize;
            }
            else if (placementView.alignOnSnap) {
                let newPos = placementView.snapLines.snapToPosition({ x: newPoint.x - offsetInControl.x, y: newPoint.y - offsetInControl.y }, null, { x: trackX > 0 ? 1 : -1, y: trackY > 0 ? 1 : -1 });
                if (newPos.x !== null) {
                    trackX = newPos.x;
                }
                else {
                    trackX = Math.round(trackX);
                }
                if (newPos.y !== null) {
                    trackY = newPos.y;
                }
                else {
                    trackY = Math.round(trackY);
                }
            }
        }
        return { x: trackX, y: trackY };
    }
    place(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        //TODO:, this should revert all undo actions while active
        //maybe a undo actions returns itself or an id so it could be changed?
        let track = this.calculateTrack(event, placementView, startPoint, offsetInControl, newPoint, items[0]);
        let filterdItems = filterChildPlaceItems(items);
        //TODO: -> what is if a transform already exists -> backup existing style.?
        for (const designItem of filterdItems) {
            const newTransform = 'translate(' + track.x + 'px, ' + track.y + 'px)';
            combineTransforms(designItem.element, designItem.styles.get('transform'), newTransform);
        }
    }
    enterContainer(container, items) {
        let filterdItems = filterChildPlaceItems(items);
        for (let i of filterdItems) {
            if (i.lastContainerSize) {
                if (!i.styles.has('width'))
                    i.setStyle('width', i.lastContainerSize.width + 'px');
                if (!i.styles.has('height'))
                    i.setStyle('height', i.lastContainerSize.height + 'px');
            }
        }
    }
    leaveContainer(container, items) {
    }
    finishPlace(event, placementView, container, startPoint, offsetInControl, newPoint, items) {
        let track = this.calculateTrack(event, placementView, startPoint, offsetInControl, newPoint, items[0]);
        let filterdItems = filterChildPlaceItems(items);
        for (const designItem of filterdItems) {
            designItem.element.style.transform = designItem.styles.get('transform') ?? '';
            placeDesignItem(container, designItem, track, 'position');
        }
    }
}
