import { DomConverter } from '../../widgets/designerView/DomConverter.js';
export class DefaultPlacementService {
  serviceForContainer(container) {
    if (container.element.style.display === 'grid' || container.element.style.display === 'inline-grid' || container.element.style.display === 'flex' || container.element.style.display === 'inline-flex') return false;
    return true;
  }

  canEnter(container, items) {
    if (DomConverter.IsSelfClosingElement(container.element.localName)) return false;
    if (container.element.shadowRoot && container.element.shadowRoot.querySelector('slot') == null) return false;
    return true;
  }

  canLeave(container, items) {
    return true;
  }

  getElementOffset(container, designItem) {
    return container.element.getBoundingClientRect();
  }

  calculateTrack(event, placementView, startPoint, newPoint, item) {
    let trackX = newPoint.x - startPoint.x;
    let trackY = newPoint.y - startPoint.y;

    if (!event.ctrlKey) {
      if (placementView.alignOnGrid) {
        trackX = Math.round(trackX / placementView.gridSize) * placementView.gridSize;
        trackY = Math.round(trackY / placementView.gridSize) * placementView.gridSize;
      } else if (placementView.alignOnSnap) {
        let rect = item.element.getBoundingClientRect();
        let newPos = placementView.snapLines.snapToPosition({
          x: newPoint.originalX - startPoint.offsetInControlX,
          y: newPoint.originalY - startPoint.offsetInControlY
        }, {
          width: rect.width,
          height: rect.height
        }, {
          x: trackX > 0 ? 1 : -1,
          y: trackY > 0 ? 1 : -1
        });

        if (newPos.x !== null) {
          trackX = newPos.x - Math.round(startPoint.originalX) + Math.round(startPoint.offsetInControlX);
        } else {
          trackX = Math.round(trackX);
        }

        if (newPos.y !== null) {
          trackY = newPos.y - Math.round(startPoint.originalY) + Math.round(startPoint.offsetInControlY);
        } else {
          trackY = Math.round(trackY);
        }
      }
    }

    return {
      x: trackX,
      y: trackY
    };
  }

  placePoint(event, placementView, container, startPoint, newPoint, items) {
    let trackX = newPoint.x;
    let trackY = newPoint.y;

    if (!event.ctrlKey) {
      if (placementView.alignOnGrid) {
        trackX = Math.round(trackX / placementView.gridSize) * placementView.gridSize;
        trackY = Math.round(trackY / placementView.gridSize) * placementView.gridSize;
      } else if (placementView.alignOnSnap) {
        let newPos = placementView.snapLines.snapToPosition({
          x: newPoint.originalX - startPoint.offsetInControlX,
          y: newPoint.originalY - startPoint.offsetInControlY
        }, null, {
          x: trackX > 0 ? 1 : -1,
          y: trackY > 0 ? 1 : -1
        });

        if (newPos.x !== null) {
          trackX = newPos.x;
        } else {
          trackX = Math.round(trackX);
        }

        if (newPos.y !== null) {
          trackY = newPos.y;
        } else {
          trackY = Math.round(trackY);
        }
      }
    }

    return {
      x: trackX,
      y: trackY
    };
  }

  place(event, placementView, container, startPoint, newPoint, items) {
    //TODO:, this should revert all undo actions while active
    //maybe a undo actions returns itself or an id so it could be changed?
    let track = this.calculateTrack(event, placementView, startPoint, newPoint, items[0]); //TODO: -> what is if a transform already exists -> backup existing style.?

    for (const designItem of items) {
      designItem.element.style.transform = 'translate(' + track.x + 'px, ' + track.y + 'px)';
    }
  }

  enterContainer(container, items) {}

  leaveContainer(container, items) {}

  finishPlace(event, placementView, container, startPoint, newPoint, items) {
    let track = this.calculateTrack(event, placementView, startPoint, newPoint, items[0]);

    for (const designItem of items) {
      let movedElement = designItem.element;
      let oldLeft = parseInt(movedElement.style.left);
      oldLeft = Number.isNaN(oldLeft) ? 0 : oldLeft;
      let oldTop = parseInt(movedElement.style.top);
      oldTop = Number.isNaN(oldTop) ? 0 : oldTop; //let oldPosition = movedElement.style.position;

      designItem.element.style.transform = null;
      designItem.setStyle('position', 'absolute');
      designItem.setStyle('left', track.x + oldLeft + "px");
      designItem.setStyle('top', track.y + oldTop + "px");
    }
  }

}