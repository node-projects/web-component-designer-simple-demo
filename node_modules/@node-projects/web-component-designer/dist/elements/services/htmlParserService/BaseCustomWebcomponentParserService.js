function* findAllNodesOfKind(node, kind) {
    if (node.kind == kind)
        yield node;
    for (const c of node.getChildren())
        yield* findAllNodesOfKind(c, kind);
}
export class BaseCustomWebcomponentParserService {
    htmlParser;
    constructor(htmlParser) {
        this.htmlParser = htmlParser;
    }
    async parse(code, serviceContainer, instanceServiceContainer, parseSnippet) {
        const sourceFile = this.parseTypescriptFile(code);
        let htmlCode = "";
        let cssStyle = "";
        //@ts-ignore
        const nodes = findAllNodesOfKind(sourceFile, ts.SyntaxKind.TaggedTemplateExpression);
        for (let nd of nodes) {
            if (nd.tag.escapedText == 'html' && nd.parent.name.escapedText == "template")
                htmlCode = nd.template.rawText;
            if (nd.tag.escapedText == 'css' && nd.parent.name.escapedText == "style")
                cssStyle = nd.template.rawText;
        }
        if (cssStyle)
            instanceServiceContainer.stylesheetService.setStylesheets([{ name: 'css', content: cssStyle }]);
        return this.htmlParser.parse(htmlCode, serviceContainer, instanceServiceContainer, parseSnippet);
    }
    writeBack(code, html, css, newLineCrLf) {
        const sourceFile = this.parseTypescriptFile(code);
        const transformTemplateLiterals = (context) => (rootNode) => {
            function visit(node) {
                //@ts-ignore
                if (ts.isTemplateLiteral(node) &&
                    //@ts-ignore
                    ts.isTaggedTemplateExpression(node.parent) &&
                    node.parent.tag.escapedText == 'html' &&
                    node.parent.parent.name.escapedText == "template") {
                    //@ts-ignore
                    return ts.factory.createNoSubstitutionTemplateLiteral(html.replaceAll('\n', '\r\n'), html.replaceAll('\n', '\r\n'));
                }
                else if (css &&
                    //@ts-ignore
                    ts.isTemplateLiteral(node) &&
                    //@ts-ignore
                    ts.isTaggedTemplateExpression(node.parent) &&
                    node.parent.tag.escapedText == 'css' &&
                    node.parent.parent.name.escapedText == "style") {
                    //@ts-ignore
                    return ts.factory.createNoSubstitutionTemplateLiteral(css.replaceAll('\n', '\r\n'), css.replaceAll('\n', '\r\n'));
                }
                //@ts-ignore
                return ts.visitEachChild(node, visit, context);
            }
            //@ts-ignore
            return ts.visitNode(rootNode, visit);
        };
        //@ts-ignore
        let transformed = ts.transform(sourceFile, [transformTemplateLiterals]).transformed[0];
        //@ts-ignore
        const printer = ts.createPrinter({ newLine: newLineCrLf ? ts.NewLineKind.CarriageReturnLineFeed : ts.NewLineKind.LineFeed });
        //@ts-ignore
        const result = printer.printNode(ts.EmitHint.Unspecified, transformed, transformed);
        return result;
    }
    parseTypescriptFile(code) {
        const compilerHost = {
            fileExists: () => true,
            getCanonicalFileName: filename => filename,
            getCurrentDirectory: () => '',
            getDefaultLibFileName: () => 'lib.d.ts',
            getNewLine: () => '\n',
            getSourceFile: filename => {
                //@ts-ignore
                return ts.createSourceFile(filename, code, ts.ScriptTarget.Latest, true);
            },
            readFile: () => null,
            useCaseSensitiveFileNames: () => true,
            writeFile: () => null,
        };
        const filename = 'aa.ts';
        //@ts-ignore
        const program = ts.createProgram([filename], {
            noResolve: true,
            //@ts-ignore
            target: ts.ScriptTarget.Latest,
        }, compilerHost);
        const sourceFile = program.getSourceFile(filename);
        return sourceFile;
    }
}
