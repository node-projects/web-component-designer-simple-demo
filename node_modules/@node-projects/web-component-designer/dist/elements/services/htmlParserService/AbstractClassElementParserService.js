function* findAllNodesOfKind(node, kind) {
    if (node.kind == kind)
        yield node;
    for (const c of node.getChildren())
        yield* findAllNodesOfKind(c, kind);
}
export class AbstractClassElementParserService {
    htmlParser;
    constructor(htmlParser) {
        this.htmlParser = htmlParser;
    }
    async parse(code, serviceContainer, instanceServiceContainer, parseSnippet) {
        const compilerHost /*: ts.CompilerHost*/ = {
            fileExists: () => true,
            getCanonicalFileName: filename => filename,
            getCurrentDirectory: () => '',
            getDefaultLibFileName: () => 'lib.d.ts',
            getNewLine: () => '\n',
            getSourceFile: filename => {
                //@ts-ignore
                return ts.createSourceFile(filename, code, ts.ScriptTarget.Latest, true);
            },
            readFile: () => null,
            useCaseSensitiveFileNames: () => true,
            writeFile: () => null,
        };
        const filename = 'aa.ts';
        //@ts-ignore
        const program = ts.createProgram([filename], {
            noResolve: true,
            //@ts-ignore
            target: ts.ScriptTarget.Latest,
        }, compilerHost);
        const sourceFile = program.getSourceFile(filename);
        let htmlCode = "";
        let cssStyle = "";
        const nodes = findAllNodesOfKind(sourceFile, 212);
        for (let nd of nodes) {
            if (nd.tag.escapedText == 'html' && nd.parent.name.escapedText == "template")
                htmlCode = nd.template.rawText;
            if (nd.tag.escapedText == 'css' && nd.parent.name.escapedText == "style")
                cssStyle = nd.template.rawText;
        }
        return this.htmlParser.parse(htmlCode, serviceContainer, instanceServiceContainer, parseSnippet);
    }
}
