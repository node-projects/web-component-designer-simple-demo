import { DomConverter } from '../../widgets/designerView/DomConverter.js';
import { NodeType } from '../../item/NodeType.js';
import { isEmptyTextNode, isInline, isInlineAfter } from '../../helper/ElementHelper.js';
import { AbstractHtmlWriterService } from './AbstractHtmlWriterService.js';
export class HtmlWriterService extends AbstractHtmlWriterService {
    _conditionalyWriteIndent(indentedTextWriter, designItem) {
        if ((designItem.element instanceof HTMLElement && !isInlineAfter(designItem.element)) ||
            (designItem.element.previousElementSibling instanceof HTMLElement && !isInline(designItem.element.previousElementSibling)) ||
            (designItem.element.previousElementSibling == null && !isInline(designItem.element.parentElement) && (designItem.element.previousSibling == null || isEmptyTextNode(designItem.element.previousSibling))) ||
            (designItem.element instanceof SVGElement))
            indentedTextWriter.writeIndent();
    }
    _conditionalyWriteIndentBefore(indentedTextWriter, designItem) {
        if ((designItem.element.previousElementSibling instanceof HTMLElement && !isInline(designItem.element.previousElementSibling)) ||
            (designItem.element.previousElementSibling == null && !isInline(designItem.element.parentElement) && (designItem.element.previousSibling == null || isEmptyTextNode(designItem.element.previousSibling))) ||
            (designItem.element instanceof SVGElement))
            indentedTextWriter.writeIndent();
    }
    _conditionalyWriteNewline(indentedTextWriter, designItem) {
        if ((designItem.element instanceof HTMLElement && !isInlineAfter(designItem.element)) ||
            (designItem.element.nextElementSibling instanceof HTMLElement && !isInline(designItem.element.nextElementSibling)) ||
            (designItem.element instanceof SVGElement))
            indentedTextWriter.writeNewline();
    }
    write(indentedTextWriter, designItems, rootContainerKeepInline, options, updatePositions = false) {
        for (const d of designItems) {
            this.internalWrite(indentedTextWriter, d, options, updatePositions);
        }
    }
    internalWrite(indentedTextWriter, designItem, options, updatePositions) {
        let start = indentedTextWriter.position;
        let end = indentedTextWriter.position;
        if (designItem.nodeType == NodeType.TextNode) {
            if (isEmptyTextNode(designItem.element) &&
                ((designItem.element.previousSibling instanceof HTMLElement && !isInlineAfter(designItem.element.previousSibling)) ||
                    (designItem.element.nextSibling instanceof HTMLElement && !isInline(designItem.element.nextSibling)))) {
            }
            else
                this.writeTextNode(indentedTextWriter, designItem, true);
            end = indentedTextWriter.position;
        }
        else if (designItem.nodeType == NodeType.Comment) {
            this._conditionalyWriteIndent(indentedTextWriter, designItem);
            start = indentedTextWriter.position;
            indentedTextWriter.write('<!--' + designItem.content + '-->');
            end = indentedTextWriter.position;
            this._conditionalyWriteNewline(indentedTextWriter, designItem);
        }
        else {
            this._conditionalyWriteIndentBefore(indentedTextWriter, designItem);
            start = indentedTextWriter.position;
            indentedTextWriter.write('<' + designItem.name);
            this.writeAttributes(indentedTextWriter, designItem, options);
            this.writeStyles(indentedTextWriter, designItem, options);
            indentedTextWriter.write('>');
            let contentSingleTextNode = false;
            if (designItem.hasChildren) {
                const children = designItem.children();
                contentSingleTextNode = designItem.childCount === 1 && designItem.firstChild.nodeType === NodeType.TextNode;
                if (contentSingleTextNode) {
                    this.writeTextNode(indentedTextWriter, designItem, false);
                }
                else {
                    if (designItem.element instanceof HTMLElement && !isInlineAfter(designItem.element) || (designItem.element instanceof SVGElement)) {
                        indentedTextWriter.writeNewline();
                        indentedTextWriter.levelRaise();
                    }
                    for (const c of children) {
                        this.internalWrite(indentedTextWriter, c, options, updatePositions);
                        let childSingleTextNode = c.childCount === 1 && c.firstChild.nodeType === NodeType.TextNode;
                        if (childSingleTextNode)
                            if (!indentedTextWriter.isLastCharNewline())
                                this._conditionalyWriteNewline(indentedTextWriter, c);
                    }
                    if (designItem.element instanceof HTMLElement && !isInlineAfter(designItem.element) || (designItem.element instanceof SVGElement)) {
                        indentedTextWriter.levelShrink();
                        if (!indentedTextWriter.isLastCharNewline())
                            indentedTextWriter.writeNewline();
                        indentedTextWriter.writeIndent();
                    }
                }
            }
            else if (designItem.hasContent) {
                indentedTextWriter.write(DomConverter.normalizeContentValue(designItem.content));
                //this._conditionalyWriteNewline(indentedTextWriter, designItem);
            }
            end = indentedTextWriter.position;
            if (!DomConverter.IsSelfClosingElement(designItem.name))
                indentedTextWriter.write('</' + designItem.name + '>');
            end = indentedTextWriter.position;
            //if (!contentSingleTextNode)
            if (!indentedTextWriter.isLastCharNewline() && (!designItem.parent || !isInlineAfter(designItem.parent.element)))
                this._conditionalyWriteNewline(indentedTextWriter, designItem);
        }
        if (updatePositions && designItem.instanceServiceContainer.designItemDocumentPositionService) {
            designItem.instanceServiceContainer.designItemDocumentPositionService.setPosition(designItem, { start: start, length: end - start });
        }
    }
    writeTextNode(indentedTextWriter, designItem, indentAndNewline) {
        let content = DomConverter.normalizeContentValue(designItem.content).trim();
        if (content) {
            if (indentAndNewline)
                this._conditionalyWriteIndent(indentedTextWriter, designItem);
            indentedTextWriter.write(content);
            if (indentAndNewline)
                this._conditionalyWriteNewline(indentedTextWriter, designItem);
        }
    }
}
