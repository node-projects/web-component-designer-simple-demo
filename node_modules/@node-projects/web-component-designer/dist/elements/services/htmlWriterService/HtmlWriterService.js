import { DomConverter } from "../../widgets/designerView/DomConverter.js";
import { CssCombiner } from "../../helper/CssCombiner.js";
import { NodeType } from "../../item/NodeType.js";
import { PropertiesHelper } from "../propertiesService/services/PropertiesHelper.js";
import { isInline } from '../../helper/ElementHelper.js';
export class HtmlWriterService {
  canWrite(designItem) {
    return true;
  }

  _conditionalyWriteIndent(indentedTextWriter, designItem) {
    if (designItem.element instanceof HTMLElement && !isInline(designItem.element) || designItem.element.previousSibling instanceof HTMLElement && !isInline(designItem.element.previousSibling)) indentedTextWriter.writeIndent();
  }

  _conditionalyWriteNewline(indentedTextWriter, designItem) {
    if (designItem.element instanceof HTMLElement && !isInline(designItem.element) || designItem.element.nextSibling instanceof HTMLElement && !isInline(designItem.element.nextSibling)) indentedTextWriter.writeNewline();
  }

  write(indentedTextWriter, designItem, options, designItemsAssignmentList) {
    let start = indentedTextWriter.position;

    if (designItem.nodeType == NodeType.TextNode) {
      this.writeTextNode(indentedTextWriter, designItem, true);
    } else if (designItem.nodeType == NodeType.Comment) {
      this._conditionalyWriteIndent(indentedTextWriter, designItem);

      indentedTextWriter.write('<!--' + designItem.content + '-->');

      this._conditionalyWriteNewline(indentedTextWriter, designItem);
    } else {
      this._conditionalyWriteIndent(indentedTextWriter, designItem);

      indentedTextWriter.write('<' + designItem.name);

      if (designItem.hasAttributes) {
        for (const a of designItem.attributes) {
          indentedTextWriter.write(' ');

          if (typeof a[1] === 'string') {
            if (a[1] === "") indentedTextWriter.write(a[0]);else indentedTextWriter.write(a[0] + '="' + DomConverter.normalizeAttributeValue(a[1]) + '"');
          } else if (!a[1]) indentedTextWriter.write(a[0]);else {//TODO: writing of bindings
          }
        }
      }

      if (designItem.hasStyles) {
        indentedTextWriter.write(' style="');
        let styles = designItem.styles;
        if (options.compressCssToShorthandProperties) styles = CssCombiner.combine(styles);

        for (const s of styles) {
          if (s[0]) {
            if (typeof s[1] === 'string') {
              indentedTextWriter.write(PropertiesHelper.camelToDashCase(s[0]) + ':' + DomConverter.normalizeAttributeValue(s[1]) + ';');
            } else {//TODO: writing of bindings
            }
          }
        }

        indentedTextWriter.write('"');
      }

      indentedTextWriter.write('>');

      if (designItem.hasChildren) {
        const children = designItem.children();
        const singleTextNode = designItem.childCount === 1 && designItem.firstChild.nodeType === NodeType.TextNode;

        if (singleTextNode) {
          this.writeTextNode(indentedTextWriter, designItem, false);
        } else {
          indentedTextWriter.writeNewline();
          indentedTextWriter.levelRaise();

          for (const c of children) {
            c.serviceContainer.forSomeServicesTillResult('htmlWriterService', s => {
              if (s.canWrite(c)) {
                s.write(indentedTextWriter, c, options, designItemsAssignmentList);
              }
            });
          }

          indentedTextWriter.levelShrink();
          indentedTextWriter.writeIndent();
        }
      } else if (designItem.hasContent) {
        indentedTextWriter.write(DomConverter.normalizeContentValue(designItem.content));
      }

      if (!DomConverter.IsSelfClosingElement(designItem.name)) indentedTextWriter.write('</' + designItem.name + '>');

      this._conditionalyWriteNewline(indentedTextWriter, designItem);
    }

    if (designItemsAssignmentList) {
      designItemsAssignmentList.set(designItem, {
        start: start,
        length: indentedTextWriter.position - start - 1
      });
    }
  }

  writeTextNode(indentedTextWriter, designItem, indentAndNewline) {
    let content = DomConverter.normalizeContentValue(designItem.content).trim();

    if (content) {
      if (indentAndNewline) this._conditionalyWriteIndent(indentedTextWriter, designItem);
      indentedTextWriter.write(content);
      if (indentAndNewline) this._conditionalyWriteNewline(indentedTextWriter, designItem);
    }
  }

}