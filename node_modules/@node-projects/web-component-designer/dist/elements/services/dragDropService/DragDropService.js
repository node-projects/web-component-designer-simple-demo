import { DesignItem } from '../../item/DesignItem.js';
import { InsertAction } from "../undoService/transactionItems/InsertAction.js";
import { ExtensionType } from "../../widgets/designerView/extensions/ExtensionType.js";
import { dragDropFormatNameElementDefinition } from "../../../Constants.js";
export class DragDropService {
    _dragOverExtensionItem;
    dragEnter(designerCanvas, event) {
    }
    dragLeave(designerCanvas, event) {
        if (this._dragOverExtensionItem) {
            designerCanvas.extensionManager.removeExtension(this._dragOverExtensionItem, ExtensionType.ContainerExternalDragOver);
            this._dragOverExtensionItem = null;
        }
    }
    dragOver(designerCanvas, event) {
        let [newContainer] = this.getPossibleContainerForDragDrop(designerCanvas, event);
        if (this._dragOverExtensionItem != newContainer) {
            designerCanvas.extensionManager.removeExtension(this._dragOverExtensionItem, ExtensionType.ContainerExternalDragOver);
            designerCanvas.extensionManager.applyExtension(newContainer, ExtensionType.ContainerExternalDragOver, event);
            this._dragOverExtensionItem = newContainer;
        }
        else {
            designerCanvas.extensionManager.refreshExtension(newContainer, ExtensionType.ContainerExternalDragOver, event);
        }
    }
    async drop(designerCanvas, event) {
        if (this._dragOverExtensionItem) {
            designerCanvas.extensionManager.removeExtension(this._dragOverExtensionItem, ExtensionType.ContainerExternalDragOver);
            this._dragOverExtensionItem = null;
        }
        let [newContainer] = this.getPossibleContainerForDragDrop(designerCanvas, event);
        if (!newContainer)
            newContainer = designerCanvas.rootDesignItem;
        //TODO : we need to use container service for adding to element, so also grid and flexbox work correct
        const transferData = event.dataTransfer.getData(dragDropFormatNameElementDefinition);
        const elementDefinition = JSON.parse(transferData);
        const di = await designerCanvas.serviceContainer.forSomeServicesTillResult("instanceService", (service) => service.getElement(elementDefinition, designerCanvas.serviceContainer, designerCanvas.instanceServiceContainer));
        const grp = di.openGroup("Insert of &lt;" + di.name + "&gt;");
        di.setStyle('position', 'absolute');
        const containerService = designerCanvas.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(newContainer, getComputedStyle(newContainer.element)));
        containerService.enterContainer(newContainer, [di]);
        const containerPos = designerCanvas.getNormalizedElementCoordinates(newContainer.element);
        const evCoord = designerCanvas.getNormalizedEventCoordinates(event);
        const pos = { x: evCoord.x - containerPos.x, y: evCoord.y - containerPos.y };
        containerService.place(event, designerCanvas, newContainer, { x: 0, y: 0 }, { x: 0, y: 0 }, pos, [di]);
        containerService.finishPlace(event, designerCanvas, newContainer, { x: 0, y: 0 }, { x: 0, y: 0 }, pos, [di]);
        designerCanvas.instanceServiceContainer.undoService.execute(new InsertAction(newContainer, newContainer.childCount, di));
        requestAnimationFrame(() => {
            designerCanvas.instanceServiceContainer.selectionService.setSelectedElements([di]);
            grp.commit();
        });
    }
    getPossibleContainerForDragDrop(designerCanvas, event) {
        let newContainerElementDesignItem = null;
        let newContainerService = null;
        const elementsFromPoint = designerCanvas.elementsFromPoint(event.x, event.y);
        for (let e of elementsFromPoint) {
            if (e == designerCanvas.rootDesignItem.element) {
                newContainerElementDesignItem = designerCanvas.rootDesignItem;
                const containerStyle = getComputedStyle(newContainerElementDesignItem.element);
                newContainerService = designerCanvas.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(newContainerElementDesignItem, containerStyle));
                break;
            }
            else if (false) {
                //check we don't try to move a item over one of its children..
            }
            else {
                newContainerElementDesignItem = DesignItem.GetOrCreateDesignItem(e, e, designerCanvas.serviceContainer, designerCanvas.instanceServiceContainer);
                const containerStyle = getComputedStyle(newContainerElementDesignItem.element);
                newContainerService = designerCanvas.serviceContainer.getLastServiceWhere('containerService', x => x.serviceForContainer(newContainerElementDesignItem, containerStyle));
                if (newContainerService) {
                    //TODO: Maybe the check for SVG Elemnt should be in "canEnterByDrop"?
                    if (newContainerService.canEnterByDrop(newContainerElementDesignItem) && !(newContainerElementDesignItem.element instanceof SVGElement)) {
                        break;
                    }
                    else {
                        newContainerElementDesignItem = null;
                        newContainerService = null;
                        continue;
                    }
                }
            }
        }
        return [newContainerElementDesignItem, newContainerService];
    }
}
