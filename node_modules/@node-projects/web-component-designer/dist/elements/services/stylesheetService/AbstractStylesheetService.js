import { TypedEvent } from "@node-projects/base-custom-webcomponent";
import { DesignerCanvas } from '../../widgets/designerView/designerCanvas.js';
export class AbstractStylesheetService {
    _stylesheets = new Map();
    _documentStylesheets = new Map();
    _allStylesheets = new Map();
    _instanceServiceContainer;
    constructor(designerCanvas) {
        this._instanceServiceContainer = designerCanvas.instanceServiceContainer;
    }
    async setStylesheets(stylesheets) {
        await this.internalSetStylesheets(stylesheets, this._stylesheets);
    }
    async setDocumentStylesheets(stylesheets) {
        await this.internalSetStylesheets(stylesheets, this._documentStylesheets);
    }
    async internalSetStylesheets(stylesheets, targetMap) {
        if (targetMap != null && stylesheets != null && targetMap.size == stylesheets.length && stylesheets.every(x => targetMap.has(x.name))) {
            for (let stylesheet of stylesheets) {
                const old = targetMap.get(stylesheet.name);
                if (old.stylesheet.content != stylesheet.content) {
                    try {
                        targetMap.set(stylesheet.name, {
                            stylesheet: stylesheet,
                            ast: await this.internalParse(stylesheet.content)
                        });
                    }
                    catch (err) {
                        console.warn("error parsing stylesheet", stylesheet, err);
                    }
                    if (targetMap == this._stylesheets)
                        this.stylesheetChanged.emit({ name: stylesheet.name, newStyle: stylesheet.content, oldStyle: old.stylesheet.content, changeSource: 'extern' });
                }
            }
        }
        else if (stylesheets != null) {
            targetMap.clear();
            for (let stylesheet of stylesheets) {
                let ast = null;
                try {
                    ast = await this.internalParse(stylesheet.content);
                }
                catch (err) {
                    console.warn("error parsing stylesheet", stylesheet, err);
                }
                targetMap.set(stylesheet.name, {
                    stylesheet: stylesheet,
                    ast: ast
                });
            }
            if (targetMap == this._stylesheets)
                this.stylesheetsChanged.emit();
        }
        else {
            targetMap.clear();
        }
        this._allStylesheets.clear();
        for (let s of this._documentStylesheets) {
            this._allStylesheets.set(s[0], s[1]);
        }
        for (let s of this._stylesheets) {
            this._allStylesheets.set(s[0], s[1]);
        }
    }
    //TODO: rename to externalStylesheets
    getStylesheets() {
        let stylesheets = [];
        for (let item of this._stylesheets) {
            stylesheets.push(item[1].stylesheet);
        }
        ;
        /*for (let item of this._documentStylesheets) {
            stylesheets.push(item[1].stylesheet);
        };*/
        return stylesheets;
    }
    updateDeclarationValue(declaration, value, important) {
        this.updateDeclarationValueWithoutUndo(declaration, value, important);
    }
    stylesheetChanged = new TypedEvent();
    stylesheetsChanged = new TypedEvent();
    elementMatchesASelector(designItem, selectors) {
        for (let selector of selectors) {
            if (selector == ':host') {
                selector = DesignerCanvas.cssprefixConstant;
            }
            if (designItem.element.matches(selector))
                return true;
        }
        return false;
    }
}
