import { AbstractStylesheetService } from "./AbstractStylesheetService.js";
export class CssToolsStylesheetService extends AbstractStylesheetService {
    _stylesheets = new Map();
    _tools;
    async setStylesheets(stylesheets) {
        if (!this._tools)
            this._tools = await import('/web-component-designer-demo/node_modules/@adobe/css-tools/dist/cjs/cssTools.js');
        if (this._stylesheets != null && stylesheets != null && this._stylesheets.size == stylesheets.length && stylesheets.every(x => this._stylesheets.has(x.name))) {
            for (let stylesheet of stylesheets) {
                const old = this._stylesheets.get(stylesheet.name);
                if (old.stylesheet.content != stylesheet.content) {
                    try {
                        this._stylesheets.set(stylesheet.name, {
                            stylesheet: stylesheet,
                            ast: this._tools.parse(stylesheet.content)
                        });
                    }
                    catch (err) {
                        console.warn("error parsing stylesheet", stylesheet, err);
                    }
                    this.stylesheetChanged.emit({ name: stylesheet.name, newStyle: stylesheet.content, oldStyle: old.stylesheet.content, changeSource: 'extern' });
                }
            }
        }
        else if (stylesheets != null) {
            this._stylesheets = new Map();
            for (let stylesheet of stylesheets) {
                try {
                    this._stylesheets.set(stylesheet.name, {
                        stylesheet: stylesheet,
                        ast: this._tools.parse(stylesheet.content)
                    });
                }
                catch (err) {
                    console.warn("error parsing stylesheet", stylesheet, err);
                }
            }
            this.stylesheetsChanged.emit();
        }
        else {
            this._stylesheets = null;
        }
    }
    getStylesheets() {
        let stylesheets = [];
        for (let item of this._stylesheets) {
            stylesheets.push(item[1].stylesheet);
        }
        ;
        return stylesheets;
    }
    getAppliedRules(designItem) {
        let rules = [];
        for (let item of this._stylesheets.entries()) {
            if (!item[1].ast?.stylesheet?.rules)
                continue;
            let rs = Array.from(this.getRulesFromAst(item[1].ast?.stylesheet?.rules, item[1].stylesheet, designItem))
                .map(x => ({
                selector: x.selectors.join(', '),
                declarations: x.declarations.filter(y => y.type == 'declaration').map(y => ({
                    name: y.property,
                    value: y.value.endsWith('!important') ? y.value.substring(0, y.value.length - 10).trimEnd() : y.value,
                    important: y.value.endsWith('!important'),
                    parent: null,
                    ast: y,
                })),
                specificity: 0,
                stylesheetName: item[0],
                ast: x,
            }));
            rs.forEach(x => x.declarations.forEach(y => y.parent = x));
            rules.push(...rs);
        }
        ;
        return rules;
    }
    *getRulesFromAst(cssAtRuleAst, stylesheet, designItem) {
        for (const atRule of cssAtRuleAst) {
            if (atRule.type == 'media') {
                yield* this.getRulesFromAst(atRule.rules, stylesheet, designItem);
            }
            else if (atRule.type == 'supports') {
                yield* this.getRulesFromAst(atRule.rules, stylesheet, designItem);
            }
            else if (atRule.type == 'rule') {
                if (this.elementMatchesASelector(designItem, atRule.selectors))
                    yield atRule;
            }
        }
        return null;
    }
    getDeclarations(designItem, styleName) {
        return this.getAppliedRules(designItem).flatMap(x => x.declarations).filter(x => x.name == styleName);
    }
    updateDeclarationValue(declaration, value, important) {
        declaration.ast.value = important ? value + ' !important' : value;
        let ss = this._stylesheets.get(declaration.parent.stylesheetName);
        this.updateStylesheet(ss);
        return true;
    }
    insertDeclarationIntoRule(rule, property, value, important) {
        rule.ast.declarations.push({
            type: 'declaration',
            property: property,
            value: important ? value + ' !important' : value
        });
        this.updateStylesheet(this._stylesheets.get(rule.stylesheetName));
        return true;
    }
    removeDeclarationFromRule(rule, property) {
        let idx = rule.ast.declarations.findIndex(x => x.property == property);
        if (idx == -1)
            return false;
        rule.ast.declarations.splice(idx, 1);
        this.updateStylesheet(this._stylesheets.get(rule.stylesheetName));
        return true;
    }
    updateStylesheet(ss) {
        const old = ss.stylesheet.content;
        ss.stylesheet.content = this._tools.stringify(ss.ast, { indent: '    ', compress: false, emptyDeclarations: true });
        this.stylesheetChanged.emit({ name: ss.stylesheet.name, newStyle: ss.stylesheet.content, oldStyle: old, changeSource: 'styleupdate' });
    }
    updateCompleteStylesheet(name, newStyle) {
        const ss = this._stylesheets.get(name);
        if (ss.stylesheet.content != newStyle) {
            const old = ss.stylesheet.content;
            ss.stylesheet.content = newStyle;
            this.stylesheetChanged.emit({ name: ss.stylesheet.name, newStyle: ss.stylesheet.content, oldStyle: old, changeSource: 'styleupdate' });
        }
    }
}
