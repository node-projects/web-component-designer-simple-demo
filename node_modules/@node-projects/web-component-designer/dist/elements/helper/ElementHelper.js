import { NodeType } from '../item/NodeType.js';
export function inDesigner(element) {
    let node = element.getRootNode();
    if (node?.host?.localName == "node-projects-designer-canvas")
        return true;
    return false;
}
export function newElementFromString(text) {
    const range = document.createRange();
    range.selectNode(document.body);
    //@ts-ignore
    const fragment = range.createContextualFragment(text, { includeShadowRoots: true });
    return fragment.firstChild;
}
export var ElementDisplayType;
(function (ElementDisplayType) {
    ElementDisplayType[ElementDisplayType["none"] = 0] = "none";
    ElementDisplayType[ElementDisplayType["inline"] = 1] = "inline";
    ElementDisplayType[ElementDisplayType["block"] = 2] = "block";
})(ElementDisplayType || (ElementDisplayType = {}));
export function isInline(element) {
    if (element instanceof SVGElement)
        return false;
    return element != null && window.getComputedStyle(element).display.startsWith('inline');
}
export function isInlineAfter(element) {
    if (element instanceof SVGElement)
        return false;
    return element != null && window.getComputedStyle(element).display.startsWith('inline');
}
export function getElementDisplaytype(element) {
    if (element instanceof SVGElement)
        return ElementDisplayType.block;
    if (element instanceof MathMLElement)
        return ElementDisplayType.block;
    const display = window.getComputedStyle(element).display;
    return display == 'none' ? ElementDisplayType.none : display.startsWith('inline') ? ElementDisplayType.inline : ElementDisplayType.block;
}
export function isEmptyTextNode(node) {
    return node.textContent.trim() == '' && node.textContent.indexOf('\xa0' /* &nbsp; */) < 0;
}
export function getActiveElement() {
    let activeElement = document.activeElement;
    let lastActive = null;
    while (activeElement != lastActive) {
        lastActive = activeElement;
        if (activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement)
            activeElement = activeElement.shadowRoot.activeElement;
    }
    return activeElement;
}
export function getParentElementIncludingSlots(element) {
    if (element.assignedSlot)
        return element.assignedSlot;
    if (element.parentElement == null) {
        if (element.parentNode instanceof ShadowRoot) {
            return element.parentNode.host;
        }
    }
    return element.parentElement;
}
const windowOffsetsCacheKey = Symbol('windowOffsetsCacheKey');
export function getElementsWindowOffsetWithoutSelfAndParentTransformations(element, zoom, cache = {}) {
    let offsetLeft = 0;
    let offsetTop = 0;
    let ch;
    if (cache)
        ch = cache[windowOffsetsCacheKey] ??= new Map();
    else
        ch = new Map();
    let lst = [];
    while (element) {
        let cachedObj = ch.get(element);
        if (cachedObj) {
            offsetLeft += cachedObj.offsetLeft;
            offsetTop += cachedObj.offsetTop;
            lst.forEach(x => { x.offsetLeft += cachedObj.offsetLeft; x.offsetTop += cachedObj.offsetTop; });
            break;
        }
        let nextParent = element.offsetParent ? element.offsetParent : element.getRootNode().host;
        if (element instanceof SVGSVGElement || element instanceof HTMLBodyElement || element instanceof HTMLHtmlElement) {
            nextParent = element.parentElement ? element.parentElement : element.getRootNode().host;
        }
        else if (element instanceof SVGGraphicsElement) {
            nextParent = element.ownerSVGElement;
        }
        else if (element instanceof MathMLElement) {
            nextParent = element.parentElement;
        }
        let scrollLeft = 0;
        let scrollTop = 0;
        if (nextParent) {
            scrollLeft = nextParent.scrollLeft ?? 0;
            scrollTop = nextParent.scrollTop ?? 0;
        }
        let currLeft = 0;
        let currTop = 0;
        if (element instanceof SVGSVGElement || element instanceof MathMLElement) {
            //TODO: !huge Perf impact! - fix without transformation
            let t = element.style.transform;
            element.style.transform = '';
            const bcEl = element.getBoundingClientRect();
            const bcPar = element.parentElement ? element.parentElement.getBoundingClientRect() : element.getRootNode().host.getBoundingClientRect();
            element.style.transform = t;
            currLeft = (bcEl.left - bcPar.left) / zoom;
            currTop = (bcEl.top - bcPar.top) / zoom;
        }
        else if (element instanceof SVGGraphicsElement) {
            let bbox = element.getBBox();
            currLeft = bbox.x;
            currTop = bbox.y;
        }
        else {
            currLeft = element.offsetLeft - scrollLeft;
            currTop = element.offsetTop - scrollTop;
        }
        lst.forEach(x => { x.offsetLeft += currLeft; x.offsetTop += currTop; });
        const cacheEntry = { offsetLeft: currLeft, offsetTop: currTop };
        lst.push(cacheEntry);
        ch.set(element, cacheEntry);
        offsetLeft += currLeft;
        offsetTop += currTop;
        element = nextParent;
    }
    return { offsetLeft: offsetLeft, offsetTop: offsetTop };
}
export function getContentBoxContentOffsets(element) {
    let xOffset = parseInt(getComputedStyle(element).paddingLeft.replace('px', ''))
        + parseInt(getComputedStyle(element).marginLeft.replace('px', ''))
        + parseInt(getComputedStyle(element).borderLeft.replace('px', ''))
        + parseInt(getComputedStyle(element).paddingRight.replace('px', ''))
        + parseInt(getComputedStyle(element).marginRight.replace('px', ''))
        + parseInt(getComputedStyle(element).borderRight.replace('px', ''));
    let yOffset = parseInt(getComputedStyle(element).paddingTop.replace('px', ''))
        + parseInt(getComputedStyle(element).marginTop.replace('px', ''))
        + parseInt(getComputedStyle(element).borderTop.replace('px', ''))
        + parseInt(getComputedStyle(element).paddingBottom.replace('px', ''))
        + parseInt(getComputedStyle(element).marginBottom.replace('px', ''))
        + parseInt(getComputedStyle(element).borderBottom.replace('px', ''));
    return { x: xOffset, y: yOffset };
}
export function calculateOuterRect(designItems, designerCanvas) {
    let min = { x: Number.MAX_VALUE, y: Number.MAX_VALUE };
    let max = { x: Number.MIN_VALUE, y: Number.MIN_VALUE };
    let elementRect;
    for (let s of designItems) {
        if (s.nodeType == NodeType.TextNode || s.nodeType == NodeType.Comment)
            continue;
        elementRect = {
            x: designerCanvas.getNormalizedElementCoordinates(s.element).x,
            y: designerCanvas.getNormalizedElementCoordinates(s.element).y,
            width: designerCanvas.getNormalizedElementCoordinates(s.element).width,
            height: designerCanvas.getNormalizedElementCoordinates(s.element).height
        };
        // calculate min and max of selection
        if (elementRect.x < min.x)
            min.x = elementRect.x;
        if (elementRect.y < min.y)
            min.y = elementRect.y;
        if (elementRect.x + elementRect.width > max.x)
            max.x = elementRect.x + elementRect.width;
        if (elementRect.y + elementRect.height > max.y)
            max.y = elementRect.y + elementRect.height;
    }
    // calculate reckt around selection
    return {
        x: min.x,
        y: min.y,
        width: max.x - min.x,
        height: max.y - min.y
    };
}
