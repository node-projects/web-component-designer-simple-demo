export function newElementFromString(text) {
    const range = document.createRange();
    range.selectNode(document.body);
    const fragment = range.createContextualFragment(text);
    return fragment.firstChild;
}
export var ElementDisplayType;
(function (ElementDisplayType) {
    ElementDisplayType[ElementDisplayType["none"] = 0] = "none";
    ElementDisplayType[ElementDisplayType["inline"] = 1] = "inline";
    ElementDisplayType[ElementDisplayType["block"] = 2] = "block";
})(ElementDisplayType || (ElementDisplayType = {}));
export function isInline(element) {
    return element != null && window.getComputedStyle(element).display.startsWith('inline');
}
export function isInlineAfter(element) {
    return element != null && window.getComputedStyle(element).display == 'inline';
}
export function getElementDisplaytype(element) {
    const display = window.getComputedStyle(element).display;
    return display == 'none' ? ElementDisplayType.none : display.startsWith('inline') ? ElementDisplayType.inline : ElementDisplayType.block;
}
export function isEmptyTextNode(node) {
    return node.textContent.trim() == '' && node.textContent.indexOf('\xa0' /* &nbsp; */) < 0;
}
export function getActiveElement() {
    let activeElement = document.activeElement;
    let lastActive = null;
    while (activeElement != lastActive) {
        lastActive = activeElement;
        if (activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement)
            activeElement = activeElement.shadowRoot.activeElement;
    }
    return activeElement;
}
export function getParentElementIncludingSlots(element) {
    if (element.assignedSlot)
        return element.assignedSlot;
    if (element.parentElement == null) {
        if (element.parentNode instanceof ShadowRoot) {
            return element.parentNode.host;
        }
    }
    return element.parentElement;
}
export function getElementsWindowOffsetWithoutSelfAndParentTransformations(element) {
    var offsetLeft = 0;
    var offsetTop = 0;
    while (element) {
        offsetLeft += element.offsetLeft;
        offsetTop += element.offsetTop;
        element = element.offsetParent;
    }
    return { offsetLeft: offsetLeft, offsetTop: offsetTop };
}
