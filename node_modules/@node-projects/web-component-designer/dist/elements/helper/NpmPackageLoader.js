import { PreDefinedElementsService } from "../services/elementsService/PreDefinedElementsService.js";
import { WebcomponentManifestElementsService } from "../services/elementsService/WebcomponentManifestElementsService.js";
import { WebcomponentManifestPropertiesService } from "../services/propertiesService/services/WebcomponentManifestPropertiesService.js";
import { removeLeading, removeTrailing } from "./Helper.js";
export class NpmPackageLoader {
    static registryPatchedTohandleErrors;
    //packageSource = '//unpkg.com/';
    _packageSource;
    _dependecies = new Map();
    constructor(packageSource = '//cdn.jsdelivr.net/npm/') {
        this._packageSource = packageSource;
        NpmPackageLoader.patchCustomElementsRegistryToHandleErrors();
    }
    static patchCustomElementsRegistryToHandleErrors() {
        if (!NpmPackageLoader.registryPatchedTohandleErrors) {
            NpmPackageLoader.registryPatchedTohandleErrors = true;
            let customElementsRegistry = window.customElements;
            const registry = {};
            registry.define = function (name, constructor, options) {
                try {
                    customElementsRegistry.define(name, constructor, options);
                }
                catch (err) {
                    console.warn(err);
                }
            };
            registry.get = function (name) {
                return customElementsRegistry.get(name);
            };
            registry.upgrade = function (node) {
                return customElementsRegistry.upgrade(node);
            };
            registry.whenDefined = function (name) {
                return customElementsRegistry.whenDefined(name);
            };
            Object.defineProperty(window, "customElements", {
                get() {
                    return registry;
                }
            });
        }
    }
    //TODO: remove paletteTree form params. elements should be added to serviceconatiner, and the container should notify
    async loadNpmPackage(pkg, serviceContainer, paletteTree, loadAllImports, reportState) {
        const baseUrl = window.location.protocol + this._packageSource + pkg + '/';
        const packageJsonUrl = baseUrl + 'package.json';
        if (reportState)
            reportState(pkg + ": loading package.json");
        const packageJson = await fetch(packageJsonUrl);
        const packageJsonObj = await packageJson.json();
        this.addToImportmap(baseUrl, packageJsonObj);
        const depPromises = [];
        if (packageJsonObj.dependencies) {
            for (let d in packageJsonObj.dependencies) {
                depPromises.push(this.loadDependency(d, packageJsonObj.dependencies[d]));
            }
        }
        await Promise.all(depPromises);
        let customElementsUrl = baseUrl + 'custom-elements.json';
        let elementsRootPath = baseUrl;
        if (packageJsonObj.customElements) {
            customElementsUrl = baseUrl + removeTrailing(packageJsonObj.customElements, '/');
            if (customElementsUrl.includes('/')) {
                let idx = customElementsUrl.lastIndexOf('/');
                elementsRootPath = customElementsUrl.substring(0, idx + 1);
            }
        }
        let webComponentDesignerUrl = baseUrl + 'web-component-designer.json';
        if (packageJsonObj.webComponentDesigner) {
            webComponentDesignerUrl = baseUrl + removeLeading(packageJsonObj.webComponentDesigner, '/');
        }
        if (reportState)
            reportState(pkg + ": loading custom-elements.json");
        let customElementsJson = await fetch(customElementsUrl);
        if (!customElementsJson.ok && packageJsonObj.homepage) {
            try {
                const url = new URL(packageJsonObj.homepage);
                const newurl = 'https://raw.githubusercontent.com/' + url.pathname + '/master/custom-elements.json';
                customElementsJson = await fetch(newurl);
                console.warn("custom-elements.json was missing from npm package, but was loaded from github as a fallback.");
            }
            catch (err) {
                console.warn("github custom elments json fallback", err);
            }
        }
        fetch(webComponentDesignerUrl).then(async (x) => {
            if (x.ok) {
                const webComponentDesignerJson = await x.json();
                if (webComponentDesignerJson.services) {
                    for (let o in webComponentDesignerJson.services) {
                        for (let s of webComponentDesignerJson.services[o]) {
                            if (s.startsWith('./'))
                                s = s.substring(2);
                            //@ts-ignore
                            const classDefinition = (await importShim(baseUrl + s)).default;
                            //@ts-ignore
                            serviceContainer.register(o, new classDefinition());
                        }
                    }
                }
            }
        });
        if (customElementsJson.ok) {
            const customElementsJsonObj = await customElementsJson.json();
            let elements = new WebcomponentManifestElementsService(packageJsonObj.name, elementsRootPath, customElementsJsonObj);
            serviceContainer.register('elementsService', elements);
            let properties = new WebcomponentManifestPropertiesService(packageJsonObj.name, customElementsJsonObj);
            serviceContainer.register('propertyService', properties);
            if (loadAllImports) {
                for (let e of await elements.getElements()) {
                    //@ts-ignore
                    importShim(e.import);
                }
            }
            //todo: should be retriggered by service container, or changeing list in container
            paletteTree.loadControls(serviceContainer, serviceContainer.elementsServices);
        }
        else {
            console.warn('npm package: ' + pkg + ' - no custom-elements.json found, only loading javascript module');
            let customElementsRegistry = window.customElements;
            const registry = {};
            const newElements = [];
            registry.define = function (name, constructor, options) {
                newElements.push(name);
                customElementsRegistry.define(name, constructor, options);
            };
            registry.get = function (name) {
                return customElementsRegistry.get(name);
            };
            registry.upgrade = function (node) {
                return customElementsRegistry.upgrade(node);
            };
            registry.whenDefined = function (name) {
                return customElementsRegistry.whenDefined(name);
            };
            Object.defineProperty(window, "customElements", {
                get() {
                    return registry;
                }
            });
            if (packageJsonObj.module) {
                //@ts-ignore
                await importShim(baseUrl + removeLeading(packageJsonObj.module, '/'));
            }
            else if (packageJsonObj.main) {
                //@ts-ignore
                await importShim(baseUrl + removeLeading(packageJsonObj.main, '/'));
            }
            else if (packageJsonObj.unpkg) {
                //@ts-ignore
                await importShim(baseUrl + removeLeading(packageJsonObj.unpkg, '/'));
            }
            else {
                console.warn('npm package: ' + pkg + ' - no entry point in package found.');
            }
            if (newElements.length > 0) {
                const elementsCfg = {
                    elements: newElements
                };
                let elService = new PreDefinedElementsService(pkg, elementsCfg);
                serviceContainer.register('elementsService', elService);
                paletteTree.loadControls(serviceContainer, serviceContainer.elementsServices);
            }
            Object.defineProperty(window, "customElements", {
                get() {
                    return customElementsRegistry;
                }
            });
        }
        if (reportState)
            reportState(pkg + ": done");
    }
    async loadDependency(dependency, version, reportState) {
        if (this._dependecies.has(dependency))
            return;
        this._dependecies.set(dependency, true);
        if (dependency.startsWith('@types')) {
            console.warn('ignoring wrong dependency: ', dependency);
            return;
        }
        if (reportState)
            reportState(dependency + ": loading dependency: " + dependency);
        const baseUrl = window.location.protocol + this._packageSource + dependency + '/';
        const packageJsonUrl = baseUrl + 'package.json';
        const packageJson = await fetch(packageJsonUrl);
        const packageJsonObj = await packageJson.json();
        const depPromises = [];
        if (packageJsonObj.dependencies) {
            for (let d in packageJsonObj.dependencies) {
                depPromises.push(this.loadDependency(d, packageJsonObj.dependencies[d]));
            }
        }
        await Promise.all(depPromises);
        this.addToImportmap(baseUrl, packageJsonObj);
    }
    async addToImportmap(baseUrl, packageJsonObj) {
        //todo - use exports of package.json for importMap
        const importMap = { imports: {}, scopes: {} };
        let mainImport = packageJsonObj.main;
        if (packageJsonObj.module)
            mainImport = packageJsonObj.module;
        importMap.imports[packageJsonObj.name] = baseUrl + removeTrailing(mainImport, '/');
        importMap.imports[packageJsonObj.name + '/'] = baseUrl;
        //@ts-ignore
        importShim.addImportMap(importMap);
    }
}
